using Noggog;
using Noggog.Notifying;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;

namespace Loqui.Generation
{
    public abstract class ObjectGeneration
    {
        public const string AUTOGENERATED = "LoquiGenerated";
        public string Name;
        public string Namespace;
        public string InternalNamespace => $"{Namespace}.Internals";
        public string FullName => $"{Namespace}.{Name}";
        public abstract bool Abstract { get; }
        public DisabledLevel Disabled { get; set; }
        public bool GenerateClass { get; set; } = true;
        public bool GenerateEquals { get; set; } = true;
        public bool GenerateToString { get; set; } = true;
        public bool GenerateNthReflections { get; set; }
        public PermissionLevel BasicCtorPermission { get; set; } = PermissionLevel.@public;
        public abstract NotifyingType NotifyingDefault { get; }
        public abstract bool HasBeenSetDefault { get; }
        public abstract bool ObjectCentralizedDefault { get; }
        public LoquiInterfaceType SetterInterfaceTypeDefault;
        public LoquiInterfaceType GetterInterfaceTypeDefault;
        public bool ObjectCentralized;
        public PermissionLevel SetPermissionDefault;
        public bool NotifyingInterface;
        public bool DerivativeDefault;
        public bool RaisePropertyChangedDefault;
        public bool HasRaisedPropertyChanged => this.IterateFields().Any((f) => f.RaisePropertyChanged);
        public int StartingIndex => this.HasLoquiBaseObject ? this.BaseClass.StartingIndex + this.BaseClass.IterateFields().Count() : 0;
        public int TotalFieldCount => this.StartingIndex + this.IterateFieldIndices().Count();
        public ClassGeneration BaseClass;
        public bool HasLoquiBaseObject => BaseClass != null;
        public string NonLoquiBaseClass;
        public bool HasNonLoquiBaseObject => !string.IsNullOrWhiteSpace(this.NonLoquiBaseClass);
        public bool HasLoquiGenerics => this.Generics.Any((g) => g.Value.BaseObjectGeneration != null);
        public bool HasNewGenerics => this.HasLoquiBaseObject && this.Generics.Any((g) => !this.BaseGenerics.ContainsKey(g.Key));
        public bool IsTopClass => BaseClass == null;
        public bool ForceInternalInterface = false;
        public HashSet<string> Interfaces = new HashSet<string>();
        public Dictionary<string, GenericDefinition> Generics = new Dictionary<string, GenericDefinition>();
        public string EmptyGenerics => (this.Generics.Count > 0 ? $"<{string.Join(",", this.Generics.Select((g) => string.Empty))}>" : string.Empty);
        public Dictionary<string, string> BaseGenerics = new Dictionary<string, string>();
        public virtual string NewOverride(Func<ObjectGeneration, bool> baseObjFilter = null, bool doIt = true) => " ";
        public virtual string ProtectedKeyword => "protected";
        public ushort? ID;
        public Guid GUID;
        public ushort Version = 0;
        public XElement Node;
        public ObjectKey Key => new ObjectKey(ProtoGen.Protocol, ID.Value, Version);
        public string FileName => $"{this.Name}_{AUTOGENERATED}.cs";
        public bool NeedsReflectionGeneration => this.GenerateNthReflections;
        public bool HasInternalInterface
        {
            get
            {
                if (this.ForceInternalInterface) return true;
                if (this.IterateFields().Any(f => f.HasInternalInterface)) return true;
                return this.BaseClassTrail().Any(b => b.HasInternalInterface);
            }
        }

        // String properties
        public string ObjectName => $"{this.Name}{this.GetGenericTypes(MaskType.Normal)}";
        public string ExtName => $"{Name}Ext";
        public string RegistrationName => $"{this.Name}_Registration";
        public string BaseGenericTypes => GenerateGenericClause(BaseGenerics.Select((g) => g.Value));
        public string BaseClassName => $"{this.BaseClass.Name}{this.BaseGenericTypes}";
        public string GenericTypes_SubTypeAssumedErrMask => $"{GenerateGenericClause(Generics.Select((g) => g.Key), GenericTypes_Assumed(MaskType.Error, onlyAssumeSubclass: true))}";
        public string GenericTypes_AssumedErrMask_CopyMask => $"{GenerateGenericClause(GenericTypes_Assumed(MaskType.Error), GenericTypes_Nickname(MaskType.Copy))}";
        public string FieldIndexName => $"{this.Name}_FieldIndex";
        public string ProtocolDefinitionName => $"{this.ProtoGen.ProtocolDefinitionName}";
        public string CommonClassName => $"{Name}Common";
        public string CommonClass => this.CommonClassName;
        public string MixInClassName => $"{Name}MixIn";

        public DirectoryInfo TargetDir { get; private set; }
        public FileInfo SourceXMLFile { get; private set; }
        protected LoquiGenerator gen;
        public ProtocolGeneration ProtoGen;
        public HashSet<string> RequiredNamespaces = new HashSet<string>();
        public List<GenerationInterface> GenerationInterfaces = new List<GenerationInterface>();
        public List<TypeGeneration> Fields = new List<TypeGeneration>();
        public IEnumerable<TypeGeneration> AllFields => this.HasLoquiBaseObject ? this.Fields.And(this.BaseClass?.AllFields) : this.Fields;
        public Dictionary<FilePath, ProjItemType> GeneratedFiles = new Dictionary<FilePath, ProjItemType>();
        public Dictionary<object, object> CustomData = new Dictionary<object, object>();

        // Task Coordinators
        protected TaskCompletionSource<List<ObjectGeneration>> _directlyInheritingObjectsTcs = new TaskCompletionSource<List<ObjectGeneration>>();
        protected Task<List<ObjectGeneration>> _directlyInheritingObjects => _directlyInheritingObjectsTcs.Task;
        public async Task<IEnumerable<ObjectGeneration>> InheritingObjects()
        {
            List<ObjectGeneration> ret = new List<ObjectGeneration>();
            var objs = await _directlyInheritingObjects;
            ret.AddRange(objs);
            ret.AddRange((await Task.WhenAll(
                objs.Select(async (o) => await o.InheritingObjects()))).SelectMany((i) => i));
            return ret;
        }
        public TaskCompletionSource LoadingCompleteTask = new TaskCompletionSource();
        protected TaskCompletionSource WiredBaseClassTCS = new TaskCompletionSource();
        public Task WiredBaseClassTask => WiredBaseClassTCS.Task;
        protected TaskCompletionSource fieldCtorsGenerated = new TaskCompletionSource();
        public Task FieldCtorsGeneratedSignal => fieldCtorsGenerated.Task;

        public ObjectGeneration(LoquiGenerator gen, ProtocolGeneration protoGen, FileInfo sourceFile)
        {
            this.gen = gen;
            this.ProtoGen = protoGen;
            this.TargetDir = sourceFile.Directory;
            this.SourceXMLFile = sourceFile;
            this.SetterInterfaceTypeDefault = this.ProtoGen.SetterInterfaceTypeDefault;
            this.GetterInterfaceTypeDefault = this.ProtoGen.GetterInterfaceTypeDefault;
            this.SetPermissionDefault = this.ProtoGen.SetPermissionDefault;
            this.DerivativeDefault = this.ProtoGen.DerivativeDefault;
            this.GenerateNthReflections = this.ProtoGen.NthReflectionDefault;
            this.GenerateToString = this.ProtoGen.ToStringDefault;
            this.RaisePropertyChangedDefault = this.ProtoGen.RaisePropertyChangedDefault;
            this.Disabled = DisabledLevel.Enabled;

            RequiredNamespaces.Add("System");
            RequiredNamespaces.Add("System.Collections");
            RequiredNamespaces.Add("System.Collections.Generic");
            RequiredNamespaces.Add("System.Linq");
            RequiredNamespaces.Add("System.Text");
            RequiredNamespaces.Add("Loqui");
            RequiredNamespaces.Add("Noggog");
            RequiredNamespaces.Add("Noggog.Notifying");
        }

        public virtual async Task Load()
        {
            Node.TransferAttribute<bool>(Constants.GENERATE_CLASS, (i) => GenerateClass = i);
            Node.TransferAttribute<bool>(Constants.GENERATE_EQUALS, (i) => GenerateEquals = i);
            Node.TransferAttribute<bool>(Constants.GENERATE_TO_STRING, (i) => GenerateToString = i);
            Node.TransferAttribute<PermissionLevel>(Constants.CTOR_PERMISSION, (i) => BasicCtorPermission = i);
            Node.TransferAttribute<ushort>(Constants.VERSION, (i) => Version = i);
            Node.TransferAttribute<bool>(Constants.FORCE_INTERNAL_INTERFACE, (i) => this.ForceInternalInterface = i);
            Node.TransferAttribute<LoquiInterfaceType>(Constants.SET_INTERFACE_TYPE_DEFAULT, (i) => this.SetterInterfaceTypeDefault = i);
            Node.TransferAttribute<LoquiInterfaceType>(Constants.GET_INTERFACE_TYPE_DEFAULT, (i) => this.GetterInterfaceTypeDefault = i);
            Node.TransferAttribute<PermissionLevel>(Constants.SET_PERMISSION_DEFAULT, (i) => this.SetPermissionDefault = i);
            Node.TransferAttribute<bool>(Constants.DERIVATIVE_DEFAULT, (i) => this.DerivativeDefault = i);
            Node.TransferAttribute<bool>(Constants.RAISEPROPERTYCHANGED_DEFAULT, (i) => this.RaisePropertyChangedDefault = i);
            Node.TransferAttribute<DisabledLevel>(Constants.DISABLE, (i) => this.Disabled = i);

            var namespacesNode = Node.Element(XName.Get(Constants.NAMESPACES, LoquiGenerator.Namespace));
            if (namespacesNode != null)
            {
                foreach (var node in namespacesNode.Elements())
                {
                    if (!string.IsNullOrWhiteSpace(node.Value))
                    {
                        this.RequiredNamespaces.Add(node.Value);
                    }
                }
            }
            RequiredNamespaces.Add(InternalNamespace);

            foreach (var genNode in Node.Elements(XName.Get(Constants.GENERIC, LoquiGenerator.Namespace)))
            {
                var generic = new GenericDefinition()
                {
                    Loqui = genNode.GetAttribute<bool>("isLoqui", defaultVal: false)
                };
                generic.Name = genNode.GetAttribute(Constants.NAME);
                generic.MustBeClass = genNode.GetAttribute<bool>(Constants.IS_CLASS);
                var baseClass = genNode.Element(XName.Get(Constants.BASE_CLASS, LoquiGenerator.Namespace));
                if (baseClass != null)
                {
                    generic.Add(baseClass.Value);
                }
                foreach (var where in genNode.Elements(XName.Get(Constants.WHERE, LoquiGenerator.Namespace)))
                {
                    generic.Add(where.Value);
                }
                this.Generics[generic.Name] = generic;
            }

            foreach (var interfNode in Node.Elements(XName.Get(Constants.INTERFACE, LoquiGenerator.Namespace)))
            {
                Interfaces.Add(interfNode.Value.Split(',').Select(s => s.Trim()));
            }

            var fieldsNode = Node.Element(XName.Get(Constants.FIELDS, LoquiGenerator.Namespace));
            if (fieldsNode != null)
            {
                foreach (var fieldNode in fieldsNode.Elements())
                {
                    var typeGen = await LoadField(fieldNode, requireName: true)
                        .TimeoutButContinue(4000, () => System.Console.WriteLine($"{this.Name}.{fieldNode.Name} loading taking a long time."));
                    if (typeGen.Succeeded)
                    {
                        Fields.Add(typeGen.Value);
                    }
                }
            }

            foreach (var interf in this.GenerationInterfaces)
            {
                interf.Modify(this);
            }

            List<ObjectGeneration> directlyInheritingObjs = new List<ObjectGeneration>();
            await Task.WhenAll(
                this.ProtoGen.Gen.ObjectGenerations.Select(
                    async (obj) =>
                    {
                        await obj.WiredBaseClassTask;
                        if (!obj.HasLoquiBaseObject) return;
                        if (!object.ReferenceEquals(obj.BaseClass, this)) return;
                        directlyInheritingObjs.Add(obj);
                    }));
            this._directlyInheritingObjectsTcs.SetResult(directlyInheritingObjs);

            await Task.WhenAll(
                this.gen.GenerationModules.Select((m) => m.PostLoad(this)
                    .TimeoutButContinue(4000, () => System.Console.WriteLine($"{m.GetType()} {this.Name} post load taking a long time."))));
        }

        public async Task<TryGet<TypeGeneration>> LoadField(XElement fieldNode, bool requireName, bool throwException = true, bool setDefaults = true, bool add = false)
        {
            if (fieldNode.NodeType == System.Xml.XmlNodeType.Comment)
            {
                return TryGet<TypeGeneration>.Failure;
            }

            if (!gen.TryGetTypeGeneration(fieldNode.Name.LocalName, out var typeGen))
            {
                if (throwException)
                {
                    throw new ArgumentException($"Unknown field type: {fieldNode.Name.LocalName}");
                }
                else
                {
                    return TryGet<TypeGeneration>.Failure;
                }
            }

            typeGen.SetObjectGeneration(this, setDefaults: setDefaults);
            await typeGen.Load(fieldNode, requireName);
            await LoadField(typeGen, fieldNode, add: add);
            return TryGet<TypeGeneration>.Succeed(typeGen);
        }

        public async Task LoadField(TypeGeneration typeGen, XElement fieldNode = null, bool add = true)
        {
            if (this.Fields.Any((f) => f.Name?.Equals(typeGen.Name) ?? false))
            {
                throw new ArgumentException("Cannot have two fields with the same name.");
            }
            if (add)
            {
                typeGen.SetObjectGeneration(this, setDefaults: true);
                this.Fields.Add(typeGen);
            }
            await Task.WhenAll(this.gen.GenerationModules.Select((m) => m.PostFieldLoad(this, typeGen, fieldNode)));
            typeGen.FinalizeField();
        }

        public async Task Generate()
        {
            if (this.Disabled != DisabledLevel.Enabled) return;
            FileGeneration fg = new FileGeneration();
            fg.AppendLine("/*");
            fg.AppendLine(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");
            fg.AppendLine(" * Autogenerated by Loqui.  Do not manually change.");
            fg.AppendLine(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");
            fg.AppendLine("*/");

            await AddNamespaces(fg);

            using (new NamespaceWrapper(fg, this.Namespace))
            {
                if (GenerateClass)
                {
                    await GenerateClassFile(fg);
                }

                await GenerateInterfaces(fg);

                await GenerateMixIns(fg);
            }
            fg.AppendLine();

            using (new NamespaceWrapper(fg, this.InternalNamespace))
            {
                GenerateEnumIndex(fg);
                await GenerateRegistration(fg);
                await GenerateCommon(fg);
                await GenerateTranslations(fg);
                GenerateLoquiInterfaces(fg);
            }

            var fileName = Path.Combine(TargetDir.FullName, FileName);
            var file = new FileInfo(fileName);
            this.GeneratedFiles[Path.GetFullPath(fileName)] = ProjItemType.Compile;
            fg.Generate(file);
            if (!this.gen.GeneratedFiles.Add(fileName))
            {
                throw new ArgumentException();
            }
        }

        public bool HasKeyField()
        {
            foreach (var field in this.IterateFields())
            {
                if (field.KeyField) return true;
            }
            if (this.HasLoquiBaseObject)
            {
                return this.BaseClass.HasKeyField();
            }
            return false;
        }

        public static string GenerateGenericClause(params string[] keys)
        {
            return GenerateGenericClause((IEnumerable<string>)keys);
        }

        public static string GenerateGenericClause(params IEnumerable<string>[] keys)
        {
            return GenerateGenericClause(keys.SelectMany((i) => i));
        }

        public static string GenerateGenericClause(IEnumerable<string> keys)
        {
            if (!keys.Any()) return string.Empty;
            return $"<{string.Join(", ", keys)}>";
        }

        public IEnumerable<string> GenerateWhereClauses(LoquiInterfaceType type, IEnumerable<KeyValuePair<string, GenericDefinition>> defs = null)
        {
            foreach (var gen in (defs ?? this.Generics))
            {
                List<string> wheres = new List<string>();
                if (gen.Value.MustBeClass
                    && (gen.Value.BaseObjectGeneration == null || type != LoquiInterfaceType.Direct))
                {
                    wheres.Add("class");
                }
                wheres.AddRange(gen.Value.GetWheres(type));
                if (wheres.Count > 0)
                {
                    yield return $"where {gen.Key} : {string.Join(", ", wheres)}";
                }
            }
        }

        public void GenerateForField(FileGeneration fg, TypeGeneration field)
        {
            if (!field.GenerateClassMembers) return;
            using (new RegionWrapper(fg, field.Name) { AppendExtraLine = false })
            {
                field.GenerateForClass(fg);
            }
        }

        private async Task GenerateClassFile(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Class"))
            {
                await GenerateClassLine(fg);

                using (new DepthWrapper(fg))
                {
                    foreach (var where in this.GenerateWhereClauses(LoquiInterfaceType.ISetter, this.Generics))
                    {
                        fg.AppendLine(where);
                    }
                }

                using (new BraceWrapper(fg))
                {
                    GenerateRouting(fg);

                    GenerateRaisePropertyChanged(fg);

                    await GenerateCtor(fg);

                    await GenerateStaticCtor(fg);
                    // Generate fields
                    foreach (var field in this.IterateFieldIndices())
                    {
                        GenerateForField(fg, field.Field);
                    }
                    fg.AppendLine();

                    if (this.GenerateNthReflections)
                    {
                        await GenerateLoquiReflectionGetterInterface(fg);

                        await GenerateLoquiReflectionSetterInterface(fg);
                    }

                    GenerateGetEqualsMaskInterfaceImplementor(fg);

                    await GenerateToStringCode(fg);

                    GenerateGetHasBeenSetMask(fg);

                    GenerateEqualsSection(fg);

                    await GenerateModules(fg);

                    GenerateInterfacesInClass(fg);

                    GenerateCopy(fg);

                    await GenerateCopyFieldsFrom(fg);

                    await GenerateSetNthObject(fg);

                    GenerateClear(fg);

                    GenerateGenericCreate(fg);
                }
            }
        }

        private async Task GenerateInterfaces(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Interface"))
            {
                await GenerateSetterInterface(fg);
                await GenerateGetterInterface(fg);
            }
        }

        protected virtual async Task GenerateMixIns(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Common MixIn"))
            {
                using (var args = new ClassWrapper(fg, $"{this.MixInClassName}"))
                {
                    args.Static = true;
                }
                using (new BraceWrapper(fg))
                {
                    await GenerateClearMixIn(fg);
                    await GenerateGetEqualsMaskMixIn(fg);
                    await GenerateToStringMixIn(fg);
                    await GenerateHasBeenSetMixIn(fg);
                    await GenerateGetHasBeenSetMaskMixIn(fg);
                }
            }
        }

        protected virtual async Task GenerateSetterInterface(FileGeneration fg)
        {
            // Interface
            using (var args = new ClassWrapper(fg, this.Interface(internalInterface: false)))
            {
                args.Type = ClassWrapper.ObjectType.@interface;
                args.Partial = true;
                args.Interfaces.Add(this.Interface(getter: true, internalInterface: false));
                if (this.HasLoquiBaseObject)
                {
                    args.Interfaces.Add(this.BaseClass.Interface(this.BaseGenericTypes));
                }
                args.Interfaces.Add($"ILoquiClass<{this.ObjectName}, {this.Interface()}, {this.Interface(getter: true)}>");
                args.Interfaces.Add(await this.GetApplicableInterfaces(LoquiInterfaceType.ISetter));
                args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.ISetter, Generics));
            }
            using (new BraceWrapper(fg))
            {
                foreach (var field in this.IterateFields())
                {
                    field.GenerateForInterface(fg, getter: false, internalInterface: false);
                }
                using (var args = new FunctionWrapper(fg,
                    $"void CopyFieldsFrom{this.GetGenericTypes(MaskType.Copy)}",
                    wheres: this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, maskTypes: MaskType.Copy))
                {
                    SemiColon = true
                })
                {
                    args.Add($"{this.Interface(getter: true)} rhs");
                    args.Add($"ErrorMaskBuilder errorMask = null");
                    args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                    args.Add($"{this.Interface(getter: true)} def = null");
                }
            }
            fg.AppendLine();

            if (HasInternalInterface)
            {
                // Internal Interface
                using (var args = new ClassWrapper(fg, this.Interface(internalInterface: true)))
                {
                    args.Type = ClassWrapper.ObjectType.@interface;
                    args.Partial = true;
                    args.BaseClass = this.BaseClassTrail().FirstOrDefault(b => b.HasInternalInterface)?.Interface(internalInterface: true);
                    args.Interfaces.Add(this.Interface(internalInterface: false));
                    args.Interfaces.Add(this.Interface(getter: true, internalInterface: true));
                    args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.ISetter, Generics));
                }
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        field.GenerateForInterface(fg, getter: false, internalInterface: true);
                    }
                }
                fg.AppendLine();
            }
        }

        protected virtual async Task GenerateGetterInterface(FileGeneration fg)
        {
            // Getter
            using (var args = new ClassWrapper(fg, this.Interface(getter: true, internalInterface: false)))
            {
                args.Type = ClassWrapper.ObjectType.@interface;
                args.Partial = true;
                args.BaseClass = (this.HasLoquiBaseObject ? this.BaseClass.Interface(this.BaseGenericTypes, getter: true) : nameof(ILoquiObject));
                args.Interfaces.Add(await this.GetApplicableInterfaces(LoquiInterfaceType.IGetter));
                args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.IGetter, Generics));
            }

            using (new BraceWrapper(fg))
            {
                foreach (var field in this.IterateFields())
                {
                    using (new RegionWrapper(fg, field.Name) { AppendExtraLine = false })
                    {
                        field.GenerateForInterface(fg, getter: true, internalInterface: false);
                    }
                }
                fg.AppendLine();

                foreach (var mod in this.gen.GenerationModules)
                {
                    using (new RegionWrapper(fg, mod.RegionString))
                    {
                        await mod.GenerateInInterfaceGetter(this, fg, internalInterface: false);
                    }
                }
            }
            fg.AppendLine();

            if (HasInternalInterface)
            {
                // Internal Getter
                using (var args = new ClassWrapper(fg, this.Interface(getter: true, internalInterface: true)))
                {
                    args.Type = ClassWrapper.ObjectType.@interface;
                    args.Partial = true;
                    args.BaseClass = this.BaseClassTrail().FirstOrDefault(b => b.HasInternalInterface)?.Interface(internalInterface: true, getter: true);
                    args.Interfaces.Add(this.Interface(getter: true));
                    args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.IGetter, Generics));
                }

                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (!field.HasInternalInterface) continue;
                        using (new RegionWrapper(fg, field.Name) { AppendExtraLine = false })
                        {
                            field.GenerateForInterface(fg, getter: true, internalInterface: true);
                        }
                    }
                    fg.AppendLine();

                    foreach (var mod in this.gen.GenerationModules)
                    {
                        using (new RegionWrapper(fg, mod.RegionString))
                        {
                            await mod.GenerateInInterfaceGetter(this, fg, internalInterface: true);
                        }
                    }
                }
                fg.AppendLine();
            }
        }

        protected void GenerateEnumIndex(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Field Index"))
            {
                fg.AppendLine($"public enum {this.FieldIndexName}");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFieldIndices(includeBaseClass: true))
                    {
                        if (!field.Field.IntegrateField) continue;
                        fg.AppendLine($"{field.Field.Name} = {field.PublicIndex},");
                    }
                }
            }
        }

        protected async Task GenerateRegistration(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Registration"))
            {
                fg.AppendLine($"public class {this.RegistrationName} : ILoquiRegistration");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"public static readonly {this.RegistrationName} Instance = new {this.RegistrationName}();");
                    fg.AppendLine();

                    fg.AppendLine($"public static ProtocolKey ProtocolKey => {this.ProtocolDefinitionName}.ProtocolKey;");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly ObjectKey ObjectKey = new ObjectKey(");
                    using (new DepthWrapper(fg))
                    {
                        fg.AppendLine($"protocolKey: {this.ProtocolDefinitionName}.ProtocolKey,");
                        fg.AppendLine($"msgID: {this.ID},");
                        fg.AppendLine($"version: {this.Version});");
                    }
                    fg.AppendLine();

                    fg.AppendLine($"public const string GUID = \"{this.GUID}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const ushort AdditionalFieldCount = {this.IterateFields().Count()};");
                    fg.AppendLine();

                    fg.AppendLine($"public const ushort FieldCount = {this.TotalFieldCount};");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type MaskType = typeof({this.GetMaskString("")});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type ErrorMaskType = typeof({this.Mask_Unspecified(MaskType.Error)});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type ClassType = typeof({this.Name}{this.EmptyGenerics});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type GetterType = typeof({this.InterfaceNoGenerics(getter: true)}{this.EmptyGenerics});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type InternalGetterType = {(this.HasInternalInterface ? $"typeof({this.InterfaceNoGenerics(getter: true, internalInterface: true)}{this.EmptyGenerics})" : "null")};");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type SetterType = typeof({this.InterfaceNoGenerics()}{this.EmptyGenerics});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type InternalSetterType = {(this.HasInternalInterface ? $"typeof({this.InterfaceNoGenerics(internalInterface: true)}{this.EmptyGenerics})" : "null")};");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type CommonType = typeof({this.CommonClassName});");
                    fg.AppendLine();

                    fg.AppendLine($"public const string FullName = \"{this.FullName}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const string Name = \"{this.Name}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const string Namespace = \"{this.Namespace}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const byte GenericCount = {this.Generics.Count};");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type GenericRegistrationType = {(this.Generics.Count > 0 ? $"typeof({this.RegistrationName}{this.EmptyGenerics})" : "null")};");
                    fg.AppendLine();

                    GenerateGetNameIndex(fg);

                    GenerateNthObjectIsEnumerable(fg);

                    GenerateNthObjectIsLoqui(fg);

                    GenerateGetNthIsSingleton(fg);

                    GenerateGetNthName(fg);

                    GenerateNthObjectIsDerivative(fg);

                    GenerateIsProtected(fg);

                    if (this.Generics.Count == 0)
                    {
                        GenerateGetNthType(fg, false);
                    }
                    else
                    {
                        fg.AppendLine("public static Type GetNthType(ushort index) => throw new ArgumentException(\"Cannot get nth type for a generic object here.  Use generic registration instead.\");");
                        fg.AppendLine();
                    }

                    foreach (var mod in this.gen.GenerationModules)
                    {
                        await mod.GenerateInRegistration(this, fg);
                    }

                    using (new RegionWrapper(fg, "Interface"))
                    {
                        fg.AppendLine($"ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;");
                        fg.AppendLine($"ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;");
                        fg.AppendLine($"string ILoquiRegistration.GUID => GUID;");
                        fg.AppendLine($"ushort ILoquiRegistration.FieldCount => FieldCount;");
                        fg.AppendLine($"ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;");
                        fg.AppendLine($"Type ILoquiRegistration.MaskType => MaskType;");
                        fg.AppendLine($"Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;");
                        fg.AppendLine($"Type ILoquiRegistration.ClassType => ClassType;");
                        fg.AppendLine($"Type ILoquiRegistration.SetterType => SetterType;");
                        fg.AppendLine($"Type ILoquiRegistration.GetterType => GetterType;");
                        fg.AppendLine($"Type ILoquiRegistration.CommonType => CommonType;");
                        fg.AppendLine($"string ILoquiRegistration.FullName => FullName;");
                        fg.AppendLine($"string ILoquiRegistration.Name => Name;");
                        fg.AppendLine($"string ILoquiRegistration.Namespace => Namespace;");
                        fg.AppendLine($"byte ILoquiRegistration.GenericCount => GenericCount;");
                        fg.AppendLine($"Type ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;");
                        fg.AppendLine($"ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => GetNameIndex(name);");
                        fg.AppendLine($"bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => GetNthIsEnumerable(index);");
                        fg.AppendLine($"bool ILoquiRegistration.GetNthIsLoqui(ushort index) => GetNthIsLoqui(index);");
                        fg.AppendLine($"bool ILoquiRegistration.GetNthIsSingleton(ushort index) => GetNthIsSingleton(index);");
                        fg.AppendLine($"string ILoquiRegistration.GetNthName(ushort index) => GetNthName(index);");
                        fg.AppendLine($"bool ILoquiRegistration.IsNthDerivative(ushort index) => IsNthDerivative(index);");
                        fg.AppendLine($"bool ILoquiRegistration.IsProtected(ushort index) => IsProtected(index);");
                        fg.AppendLine($"Type ILoquiRegistration.GetNthType(ushort index) => GetNthType(index);");

                    }
                }

                if (this.Generics.Count > 0)
                {
                    fg.AppendLine();
                    using (var args = new ClassWrapper(fg, $"{this.RegistrationName}{this.GetGenericTypes(MaskType.Normal)}"))
                    {
                        args.Interfaces.Add(this.RegistrationName);
                        args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.Direct, Generics));
                    }
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"public static readonly {this.RegistrationName}{this.GetGenericTypes(MaskType.Normal)} GenericInstance = new {this.RegistrationName}{this.GetGenericTypes(MaskType.Normal)}();");
                        fg.AppendLine();

                        GenerateGetNthType(fg, true);
                    }
                }
            }
        }

        private async Task GenerateCommon(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Common"))
            {
                using (var args = new ClassWrapper(fg, $"{this.CommonClass}"))
                {
                    args.Partial = true;
                    args.BaseClass = this.BaseClass?.CommonClassName;
                }
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"public static readonly {this.CommonClass} Instance = new {this.CommonClassName}();");
                    fg.AppendLine();

                    GenerateCopyFieldsFromExtension(fg);

                    if (this.GenerateNthReflections)
                    {
                        GenerateSetNthObjectHasBeenSet(fg);

                        GenerateUnsetNthObject(fg);

                        GenerateGetNthObjectHasBeenSet(fg);

                        GenerateGetNthObject(fg);
                    }

                    await GenerateClearCommon(fg);

                    GenerateGetEqualsMask(fg);

                    GenerateCommonToString(fg);

                    GenerateHasBeenSetCheck(fg);

                    GenerateHasBeenSetMaskGetter(fg);

                    GenerateFieldIndexConverters(fg, this);

                    // Fields might add some content
                    foreach (var field in this.IterateFields())
                    {
                        field.GenerateForInterfaceExt(fg);
                    }

                    // Modules might add some content
                    foreach (var mod in this.gen.GenerationModules)
                    {
                        using (new RegionWrapper(fg, mod.RegionString))
                        {
                            await mod.GenerateInCommonExt(this, fg);
                        }
                    }
                }
            }
        }

        private async Task GenerateToStringMixIn(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static string ToString{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"this {this.Interface(getter: true)} item");
                args.Add($"string name = null");
                args.Add($"{this.GetMaskString("bool")} printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return (({this.CommonClass})item.CommonInstance).ToString"))
                {
                    args.Add("item: item");
                    args.Add("name: name");
                    args.Add("printMask: printMask");
                }
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static void ToString{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"this {this.Interface(getter: true)} item");
                args.Add($"{nameof(FileGeneration)} fg");
                args.Add($"string name = null");
                args.Add($"{this.GetMaskString("bool")} printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"(({this.CommonClass})item.CommonInstance).ToString"))
                {
                    args.Add("item: item");
                    args.Add("fg: fg");
                    args.Add("name: name");
                    args.Add("printMask: printMask");
                }
            }
            fg.AppendLine();
        }

        private void GenerateCommonToString(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public string ToString{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"{this.Interface(getter: true)} item");
                args.Add($"string name = null");
                args.Add($"{this.GetMaskString("bool")} printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var fg = new {nameof(FileGeneration)}();");
                using (var args = new ArgsWrapper(fg,
                    $"ToString"))
                {
                    args.Add("item: item");
                    args.Add("fg: fg");
                    args.Add("name: name");
                    args.Add("printMask: printMask");
                }
                fg.AppendLine("return fg.ToString();");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public void ToString{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"{this.Interface(getter: true)} item");
                args.Add($"{nameof(FileGeneration)} fg");
                args.Add($"string name = null");
                args.Add($"{this.GetMaskString("bool")} printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("if (name == null)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"fg.AppendLine($\"{{nameof({this.ObjectName})}} =>\");");
                }
                fg.AppendLine("else");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"fg.AppendLine($\"{{name}} ({{nameof({this.ObjectName})}}) =>\");");
                }
                fg.AppendLine($"fg.AppendLine(\"[\");");
                fg.AppendLine($"using (new DepthWrapper(fg))");
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        $"ToStringFields"))
                    {
                        args.Add("item: item");
                        args.Add("fg: fg");
                        args.Add("printMask: printMask");
                    }
                }
                fg.AppendLine($"fg.AppendLine(\"]\");");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"protected static void ToStringFields{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"{this.Interface(getter: true)} item");
                args.Add($"{nameof(FileGeneration)} fg");
                args.Add($"{this.GetMaskString("bool")} printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                if (this.HasLoquiBaseObject)
                {
                    using (var args = new ArgsWrapper(fg,
                        $"{this.BaseClass.CommonClassName}.ToStringFields"))
                    {
                        args.Add("item: item");
                        args.Add("fg: fg");
                        args.Add("printMask: printMask");
                    }
                }
                foreach (var field in this.IterateFields())
                {
                    if (field.IntegrateField)
                    {
                        fg.AppendLine($"if ({gen.MaskModule.GetMaskModule(field.GetType()).GenerateBoolMaskCheck(field, "printMask")})");
                    }
                    using (new BraceWrapper(fg, doIt: field.IntegrateField))
                    {
                        field.GenerateToString(fg, field.Name, new Accessor(field, "item."), "fg");
                    }
                }
            }
            fg.AppendLine();
        }

        private async Task GenerateHasBeenSetMixIn(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static bool HasBeenSet{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"this {this.Interface(getter: true)} item");
                args.Add($"{this.GetMaskString("bool?")} checkMask");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return (({this.CommonClass})item.CommonInstance).HasBeenSet"))
                {
                    args.AddPassArg("item");
                    args.AddPassArg("checkMask");
                }
            }
            fg.AppendLine();
        }

        private void GenerateHasBeenSetCheck(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public bool HasBeenSet{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"{this.Interface(getter: true)} item");
                args.Add($"{this.GetMaskString("bool?")} checkMask");
            }
            using (new BraceWrapper(fg))
            {
                foreach (var field in this.IterateFieldIndices())
                {
                    if (field.Field.Bare) continue;
                    field.Field.GenerateForHasBeenSetCheck(fg, new Accessor(field.Field, "item."), $"checkMask.{field.Field.Name}");
                }
                if (this.HasLoquiBaseObject)
                {
                    using (var args = new ArgsWrapper(fg,
                        "return base.HasBeenSet"))
                    {
                        args.AddPassArg("item");
                        args.AddPassArg("checkMask");
                    }
                }
                else
                {
                    fg.AppendLine("return true;");
                }
            }
            fg.AppendLine();
        }

        private async Task GenerateGetHasBeenSetMaskMixIn(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static {this.GetMaskString("bool")} GetHasBeenSetMask{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"this {this.Interface(getter: true)} item");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var ret = new {this.GetMaskString("bool")}();");
                using (var args = new ArgsWrapper(fg,
                    $"(({this.CommonClass})item.CommonInstance).FillHasBeenSetMask"))
                {
                    args.AddPassArg("item");
                    args.Add("mask: ret");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();
        }

        private void GenerateHasBeenSetMaskGetter(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public void FillHasBeenSetMask{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"{this.Interface(getter: true)} item");
                args.Add($"{this.GetMaskString("bool")} mask");
            }
            using (new BraceWrapper(fg))
            {
                foreach (var field in this.IterateFieldIndices())
                {
                    field.Field.GenerateForHasBeenSetMaskGetter(fg, new Accessor(field.Field, "item."), $"mask.{field.Field.Name}");
                }
                if (this.HasLoquiBaseObject)
                {
                    using (var args = new ArgsWrapper(fg,
                        "base.FillHasBeenSetMask"))
                    {
                        args.Add($"item: item");
                        args.Add($"mask: mask");
                    }
                }
            }
            fg.AppendLine();
        }

        private void GenerateFieldIndexConverters(FileGeneration fg, ObjectGeneration obj)
        {
            if (!obj.HasLoquiBaseObject) return;
            var baseObj = obj.BaseClass;
            using (var args = new FunctionWrapper(fg,
                $"public static {this.FieldIndexName} ConvertFieldIndex"))
            {
                args.Add($"{baseObj.FieldIndexName} index");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("switch (index)");
                using (new BraceWrapper(fg))
                {
                    foreach (var (PublicIndex, InternalIndex, Field) in baseObj.IterateFieldIndices(includeBaseClass: true))
                    {
                        fg.AppendLine($"case {baseObj.FieldIndexName}.{Field.Name}:");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"return ({this.FieldIndexName})((int)index);");
                        }
                    }

                    fg.AppendLine("default:");
                    using (new DepthWrapper(fg))
                    {
                        GenerateIndexOutOfRangeEx(fg, $"index.{nameof(EnumExt.ToStringFast_Enum_Only)}()");
                    }
                }
            }
            fg.AppendLine();
            GenerateFieldIndexConverters(fg, baseObj);
        }

        protected virtual void GenerateStaticCopy_ToLoqui(FileGeneration fg)
        {
            fg.AppendLine($"return {this.ObjectName}.Copy(item, def: null);");
        }

        protected virtual async Task GenerateCopyFieldsFrom(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public{this.FunctionOverride()}void CopyFieldsFrom{this.GetGenericTypes(MaskType.Copy)}",
                this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, maskTypes: MaskType.Copy)))
            {
                args.Add($"{(this.BaseClassTrail().LastOrDefault() ?? this).Interface(getter: true)} rhs");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"this.CopyFieldsFrom{this.GenericTypes_AssumedErrMask_CopyMask}"))
                {
                    args.Add($"rhs: ({this.Interface(getter: true)})rhs");
                    args.Add("def: null");
                    args.Add("doMasks: false");
                    args.Add($"errorMask: out var errMask");
                    args.Add("copyMask: null");
                }
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public void CopyFieldsFrom{this.GetGenericTypes(MaskType.Copy)}",
                this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, maskTypes: MaskType.Copy)))
            {
                args.Add($"{this.Interface(getter: true)} rhs");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask");
                args.Add($"{this.Interface(getter: true)} def = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"this.CopyFieldsFrom{this.GenericTypes_AssumedErrMask_CopyMask}"))
                {
                    args.Add("rhs: rhs");
                    args.Add("def: def");
                    args.Add("doMasks: false");
                    args.Add("errorMask: out var errMask");
                    args.Add("copyMask: copyMask");
                }
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public void CopyFieldsFrom{this.GetGenericTypes(MaskType.Error, MaskType.Copy)}",
                wheres: this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Error, MaskType.Copy)))
            {
                args.Add($"{this.Interface(getter: true)} rhs");
                args.Add($"out {this.Mask(MaskType.Error)} errorMask");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                args.Add($"{this.Interface(getter: true)} def = null");
                args.Add($"bool doMasks = true");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var errorMaskBuilder = new ErrorMaskBuilder();");
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClass}.CopyFieldsFrom{GetGenericTypes(MaskType.Normal, MaskType.Copy)}"))
                {
                    args.Add("item: this");
                    args.Add("rhs: rhs");
                    args.Add("def: def");
                    args.Add("errorMask: errorMaskBuilder");
                    args.Add("copyMask: copyMask");
                }
                fg.AppendLine($"errorMask = {this.Mask(MaskType.Error)}.Factory(errorMaskBuilder);");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public void CopyFieldsFrom{this.GetGenericTypes(MaskType.Copy)}",
                wheres: this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, maskTypes: MaskType.Copy)))
            {
                args.Add($"{this.Interface(getter: true)} rhs");
                args.Add($"ErrorMaskBuilder errorMask");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                args.Add($"{this.Interface(getter: true)} def = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClass}.CopyFieldsFrom{this.GetGenericTypes(MaskType.Normal, MaskType.Copy)}"))
                {
                    args.Add("item: this");
                    args.Add("rhs: rhs");
                    args.Add("def: def");
                    args.Add("errorMask: errorMask");
                    args.Add("copyMask: copyMask");
                }
            }
            fg.AppendLine();
        }

        protected virtual void GenerateCopyFieldsFromExtension(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Copy Fields From"))
            {
                using (var args = new FunctionWrapper(fg,
                    $"public static void CopyFieldsFrom{this.GetGenericTypes(MaskType.Normal, MaskType.Copy)}",
                    wheres: this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy).ToArray()))
                {
                    args.Add($"{this.Interface()} item");
                    args.Add($"{this.Interface(getter: true)} rhs");
                    args.Add($"{this.Interface(getter: true)} def");
                    args.Add($"ErrorMaskBuilder errorMask");
                    args.Add($"{this.Mask(MaskType.Copy)} copyMask");
                }
                using (new BraceWrapper(fg))
                {
                    GenerateCopyForFields(
                        fg,
                        "item",
                        "rhs",
                        defaultFallbackAccessor: "def",
                        errMaskAccessor: "errorMask",
                        copyMaskAccessor: "copyMask");
                }
                fg.AppendLine();
            }
        }

        private void GenerateCopyForFields(
            FileGeneration fg,
            string accessorPrefix,
            string rhsAccessorPrefix,
            string defaultFallbackAccessor,
            string errMaskAccessor,
            string copyMaskAccessor)
        {
            if (this.HasLoquiBaseObject)
            {
                using (var args = new ArgsWrapper(fg,
                    $"{this.BaseClass.CommonClassName}.CopyFieldsFrom{this.GetBaseGenericTypes(MaskType.Error, MaskType.Copy)}"))
                {
                    args.Add(accessorPrefix);
                    args.Add(rhsAccessorPrefix);
                    args.Add(defaultFallbackAccessor);
                    args.Add(errMaskAccessor);
                    args.Add(copyMaskAccessor);
                }
            }

            foreach (var item in this.IterateFieldIndices())
            {
                if (!item.Field.Copy || !item.Field.IntegrateField) continue;
                // ToDo
                // Add internal interface support
                if (item.Field.HasInternalInterface) continue;
                fg.AppendLine($"if ({item.Field.SkipCheck(copyMaskAccessor)})");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"errorMask?.PushIndex((int){item.Field.IndexEnumName});");
                    if (item.Field.CopyNeedsTryCatch)
                    {
                        fg.AppendLine("try");
                        using (new BraceWrapper(fg))
                        {
                            item.Field.GenerateForCopy(
                                fg,
                                new Accessor(item.Field, $"{accessorPrefix}."),
                                rhsAccessorPrefix,
                                $"{copyMaskAccessor}?.{item.Field.Name}",
                                defaultFallbackAccessor,
                                protectedMembers: false);
                        }
                        GenerateExceptionCatcher(fg, item.Field, errMaskAccessor, $"{item.Field.IndexEnumName}");
                    }
                    else
                    {
                        item.Field.GenerateForCopy(
                            fg,
                            new Accessor(item.Field, $"{accessorPrefix}."),
                            rhsAccessorPrefix,
                            $"{copyMaskAccessor}.{item.Field.Name}",
                            defaultFallbackAccessor,
                            protectedMembers: false);
                        fg.AppendLine("errorMask?.PopIndex();");
                    }
                }
            }
        }

        #region Generation Snippets
        public void GenerateRouting(FileGeneration fg)
        {
            fg.AppendLine($"[DebuggerBrowsable(DebuggerBrowsableState.Never)]");
            fg.AppendLine($"ILoquiRegistration ILoquiObject.Registration => {this.RegistrationName}.Instance;");
            fg.AppendLine($"public{NewOverride()}static {this.RegistrationName} Registration => {this.RegistrationName}.Instance;");
            fg.AppendLine($"protected{this.FunctionOverride()}object CommonInstance => {this.CommonClass}.Instance;");
            if (this.IsTopClass)
            {
                fg.AppendLine($"object {nameof(ILoquiObject)}.CommonInstance => this.CommonInstance;");
            }
            fg.AppendLine();
        }

        protected void GenerateRaisePropertyChanged(FileGeneration fg)
        {
            if (!this.HasRaisedPropertyChanged) return;
            using (new RegionWrapper(fg, "PropertyChangedHandler"))
            {
                fg.AppendLine($"public event PropertyChangedEventHandler PropertyChanged;");
                fg.AppendLine();

                fg.AppendLine($"protected void OnPropertyChanged(string name)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));");
                }
            }
        }

        protected abstract Task GenerateCtor(FileGeneration fg);

        protected async Task GenerateStaticCtor(FileGeneration fg)
        {
            FileGeneration staticCtorFG = new FileGeneration();
            foreach (var mod in this.gen.GenerationModules)
            {
                await mod.GenerateInStaticCtor(this, staticCtorFG);
            }
            foreach (var field in this.IterateFields())
            {
                field.GenerateForStaticCtor(staticCtorFG);
            }
            if (staticCtorFG.Strings.Count == 0) return;
            fg.AppendLine($"static {this.Name}()");
            using (new BraceWrapper(fg))
            {
                fg.AppendLines(staticCtorFG.Strings);
            }
            fg.AppendLine();
        }

        protected abstract Task GenerateClassLine(FileGeneration fg);

        public async Task GenerateLoquiReflectionGetterInterface(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Loqui Getter Interface"))
            {
                fg.AppendLine();

                fg.AppendLine($"protected{this.FunctionOverride()}object GetNthObject(ushort index) => {this.CommonClassName}.GetNthObject{this.GetGenericTypes(MaskType.Normal)}(index, this);");
                if (this.IsTopClass)
                {
                    fg.AppendLine($"object {nameof(ILoquiReflectionGetter)}.GetNthObject(ushort index) => this.GetNthObject(index);");
                }
                fg.AppendLine();

                using (new LineWrapper(fg))
                {
                    fg.Append($"protected{this.FunctionOverride()}bool GetNthObjectHasBeenSet(ushort index) => ");
                    if (this is ClassGeneration)
                    {
                        fg.Append($"{this.CommonClassName}.GetNthObjectHasBeenSet{this.GetGenericTypes(MaskType.Normal)}(index, this);");
                    }
                    else
                    {
                        fg.Append("true;");
                    }
                }
                if (this.IsTopClass)
                {
                    fg.AppendLine($"bool {nameof(ILoquiReflectionGetter)}.GetNthObjectHasBeenSet(ushort index) => this.GetNthObjectHasBeenSet(index);");
                }
                fg.AppendLine();

                fg.AppendLine($"protected{this.FunctionOverride()}void UnsetNthObject(ushort index) => {this.CommonClassName}.UnsetNthObject{this.GetGenericTypes(MaskType.Normal)}(index, this);");
                if (this.IsTopClass)
                {
                    fg.AppendLine($"void {nameof(ILoquiReflectionSetter)}.UnsetNthObject(ushort index) => this.UnsetNthObject(index);");
                }
                fg.AppendLine();
            }
        }

        protected virtual async Task GenerateLoquiReflectionSetterInterface(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Loqui Interface"))
            {
                fg.AppendLine($"protected{this.FunctionOverride()}void SetNthObjectHasBeenSet(ushort index, bool on)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"{this.CommonClassName}.SetNthObjectHasBeenSet{this.GetGenericTypes(MaskType.Normal)}(index, on, this);");
                }
                if (this.IsTopClass)
                {
                    fg.AppendLine($"void {nameof(ILoquiReflectionSetter)}.SetNthObjectHasBeenSet(ushort index, bool on) => this.SetNthObjectHasBeenSet(index, on);");
                }
                fg.AppendLine();
            }
        }

        private async Task GenerateProtocolProperty(FileGeneration fg)
        {
            fg.AppendLine($"public static ProtocolKey Loqui_ProtocolKey_Static => new ProtocolKey({ProtoGen.Protocol.Namespace});");

            fg.AppendLine($"public{this.FunctionOverride()}ProtocolKey Loqui_ProtocolKey => Loqui_ProtocolKey_Static;");

            fg.AppendLine($"public static ObjectKey Loqui_ObjectKey_Static => new ObjectKey(protocolKey: Loqui_ProtocolKey_Static, msgID: {this.ID}, version: {this.Version});");

            fg.AppendLine($"public{this.FunctionOverride()}ObjectKey Loqui_ObjectKey => Loqui_ObjectKey_Static;");
        }

        private void GenerateGetNthObject(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static object GetNthObject"))
            {
                args.Add($"ushort index");
                args.Add($"{this.Interface(getter: true)} obj");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNth(fg, new Accessor(field, "obj."));
                        }
                    }

                    GenerateStandardIndexDefault(fg, "GetNthObject", "index", true, true, "obj");
                }
            }
            fg.AppendLine();
        }

        protected virtual void GenerateGetNthObjectHasBeenSet(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static bool GetNthObjectHasBeenSet"))
            {
                args.Add($"ushort index");
                args.Add($"{this.Interface()} obj");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var nonNotifying = IterateFieldIndices()
                        .Where((f) => !f.Field.HasBeenSet).ToList();
                    if (nonNotifying.Count > 0)
                    {
                        foreach (var item in nonNotifying)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"return true;");
                        }
                    }

                    foreach (var field in this.IterateFields().Where((field) => field.HasBeenSet))
                    {
                        if (field.IntegrateField)
                        {
                            if (field.Bare) continue;
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNthObjectHasBeenSet(fg);
                        }
                    }

                    GenerateStandardIndexDefault(fg, "GetNthObjectHasBeenSet", "index", true, true, "obj");
                }
            }
            fg.AppendLine();
        }

        protected virtual async Task GenerateSetNthObject(FileGeneration fg)
        {
            if (this.IsTopClass && this.GenerateNthReflections)
            {
                fg.AppendLine($"void {nameof(ILoquiReflectionSetter)}.SetNthObject(ushort index, object obj) => this.SetNthObject(index, obj);");
            }
            fg.AppendLine($"protected{this.FunctionOverride()}void SetNthObject(ushort index, object obj)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var derivatives = IterateFieldIndices()
                        .Where((f) => f.Field.Derivative).ToList();
                    if (derivatives.Count > 0)
                    {
                        foreach (var item in derivatives)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("throw new ArgumentException($\"Tried to set at a derivative index {index}\");");
                        }
                    }
                    foreach (var field in this.IterateFields())
                    {
                        if (field.Derivative) continue;
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateSetNth(
                                fg,
                                accessorPrefix: $"this",
                                rhsAccessorPrefix: $"({field.SetToName})obj",
                                internalUse: false);
                        }
                    }

                    GenerateStandardIndexDefault(fg, "SetNthObject", "index", false, false, "obj");
                }
            }
            fg.AppendLine();
        }

        protected virtual void GenerateSetNthObjectHasBeenSet(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static void SetNthObjectHasBeenSet"))
            {
                args.Add($"ushort index");
                args.Add($"bool on");
                args.Add($"{this.Interface()} obj");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    HashSet<int> coveredFields = new HashSet<int>();

                    // Non integrated fields
                    foreach (var field in this.IterateFieldIndices())
                    {
                        if (field.Field.IntegrateField) continue;
                        coveredFields.Add(field.PublicIndex);
                    }

                    // Derivative fields
                    var derivatives = IterateFieldIndices()
                        .Where((f) => f.Field.Derivative && coveredFields.Add(f.PublicIndex)).ToList();
                    if (derivatives.Count > 0)
                    {
                        foreach (var item in derivatives)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("throw new ArgumentException($\"Tried to set at a derivative index {index}\");");
                        }
                    }

                    // Non Has Been Set
                    var nonHasBeenSetFields = IterateFieldIndices().
                        Where((f) =>
                            !f.Field.HasBeenSet
                            && coveredFields.Add(f.PublicIndex))
                        .ToList();
                    if (nonHasBeenSetFields.Count > 0)
                    {
                        foreach (var field in nonHasBeenSetFields.Select((f) => f.Field))
                        {
                            if (field.Derivative) continue;
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("if (on) break;");
                            fg.AppendLine("throw new ArgumentException(\"Tried to unset a field which does not have this functionality.\" + index);");
                        }
                    }

                    // Protected
                    var protectedFields = IterateFieldIndices().
                        Where((f) =>
                            f.Field.ReadOnly
                            && coveredFields.Add(f.PublicIndex))
                        .ToList();
                    if (protectedFields.Count > 0)
                    {
                        foreach (var field in protectedFields.Select((f) => f.Field))
                        {
                            if (field.Derivative) continue;
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("throw new ArgumentException(\"Tried to set at a readonly index \" + index);");
                        }
                    }

                    // Normal
                    foreach (var field in this.IterateFieldIndices().Where((f) => coveredFields.Add(f.PublicIndex)).Select((f) => f.Field))
                    {
                        fg.AppendLine($"case {field.IndexEnumName}:");
                        using (new DepthWrapper(fg))
                        {
                            field.GenerateSetNthHasBeenSet(fg, new Accessor(field, "obj."), "on");
                        }
                    }

                    GenerateStandardIndexDefault(fg, "SetNthObjectHasBeenSet", "index", false, true, "on", "obj");
                }
            }
            fg.AppendLine();
        }

        protected virtual void GenerateUnsetNthObject(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static void UnsetNthObject"))
            {
                args.Add("ushort index");
                args.Add($"{this.Interface()} obj");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var derivatives = IterateFieldIndices()
                        .Where((f) => f.Field.Derivative).ToList();
                    if (derivatives.Count > 0)
                    {
                        foreach (var item in derivatives)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("throw new ArgumentException($\"Tried to unset at a derivative index {index}\");");
                        }
                    }
                    foreach (var field in this.IterateFields())
                    {
                        if (field.Derivative) continue;

                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            if (field.IntegrateField && field.ReadOnly)
                            {
                                fg.AppendLine("throw new ArgumentException(\"Tried to set at a readonly index \" + index);");
                            }
                            else
                            {
                                field.GenerateUnsetNth(fg, new Accessor(field, "obj."));
                            }
                        }
                    }

                    GenerateStandardIndexDefault(fg, "UnsetNthObject", "index", false, true, "obj");
                }
            }
            fg.AppendLine();
        }

        private void GenerateNthObjectIsLoqui(FileGeneration fg)
        {
            fg.AppendLine("public static bool GetNthIsLoqui(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    Func<TypeGeneration, bool> tester = (t) =>
                    {
                        if (t is LoquiType)
                        {
                            return true;
                        }
                        else if (t is ContainerType)
                        {
                            ContainerType listField = t as ContainerType;
                            if (listField.SubTypeGeneration is LoquiType)
                            {
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                        else
                        {
                            return false;
                        }
                    };

                    var trues = IterateFieldIndices().Where((i) => tester(i.Field));
                    var falses = IterateFieldIndices().Where((i) => !tester(i.Field));
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthIsLoqui", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateNthObjectIsDerivative(FileGeneration fg)
        {
            fg.AppendLine("public static bool IsNthDerivative(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var trues = IterateFieldIndices().Where((i) => i.Field.Derivative);
                    var falses = IterateFieldIndices().Where((i) => !i.Field.Derivative);
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "IsNthDerivative", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateNthObjectIsEnumerable(FileGeneration fg)
        {
            fg.AppendLine("public static bool GetNthIsEnumerable(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var trues = IterateFieldIndices().Where((i) => i.Field is ContainerType);
                    var falses = IterateFieldIndices().Where((i) => !(i.Field is ContainerType));
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthIsEnumerable", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetNthType(FileGeneration fg, bool generic)
        {
            fg.AppendLine($"public{(generic ? " new " : " ")}static Type GetNthType(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNthType(fg);
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthType", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetNthName(FileGeneration fg)
        {
            fg.AppendLine("public static string GetNthName(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNthName(fg);
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthName", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetNthIsSingleton(FileGeneration fg)
        {
            fg.AppendLine("public static bool GetNthIsSingleton(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    Func<TypeGeneration, bool> tester = (f) =>
                    {
                        if (!(f is LoquiType loqui)) return false;
                        return loqui.SingletonType == SingletonLevel.Singleton;
                    };
                    var trues = IterateFieldIndices().Where((i) => tester(i.Field));
                    var falses = IterateFieldIndices().Where((i) => !tester(i.Field));
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthIsSingleton", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetEqualsMaskInterfaceImplementor(FileGeneration fg)
        {
            fg.AppendLine($"IMask<bool> IEqualsMask<{this.ObjectName}>.GetEqualsMask({this.ObjectName} rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask(rhs, include);");
            fg.AppendLine($"IMask<bool> IEqualsMask<{this.Interface(getter: true)}>.GetEqualsMask({this.Interface(getter: true)} rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask(rhs, include);");
        }

        protected virtual async Task GenerateGetEqualsMaskMixIn(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg, $"public static {this.GetMaskString("bool")} GetEqualsMask{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"this {this.Interface(getter: true)} item");
                args.Add($"{this.Interface(getter: true)} rhs");
                args.Add($"EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return (({this.CommonClass})item.CommonInstance).GetEqualsMask"))
                {
                    args.AddPassArg("item");
                    args.AddPassArg("rhs");
                    args.AddPassArg("include");
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetEqualsMask(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg, $"public {this.GetMaskString("bool")} GetEqualsMask{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"{this.Interface(getter: true)} item");
                args.Add($"{this.Interface(getter: true)} rhs");
                args.Add($"EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var ret = new {this.GetMaskString("bool")}();");
                using (var args = new ArgsWrapper(fg,
                    $"(({this.CommonClass})item.CommonInstance).FillEqualsMask"))
                {
                    args.AddPassArg("item");
                    args.AddPassArg("rhs");
                    args.AddPassArg("ret");
                    args.AddPassArg("include");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg, $"public void FillEqualsMask{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.IGetter).ToArray()))
            {
                args.Add($"{this.Interface(getter: true)} item");
                args.Add($"{this.Interface(getter: true)} rhs");
                args.Add($"{this.GetMaskString("bool")} ret");
                args.Add($"EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("if (rhs == null) return;");
                foreach (var field in this.IterateFields())
                {
                    if (!HasKeyField() || field.KeyField)
                    {
                        field.GenerateForEqualsMask(
                            fg,
                            new Accessor(field, $"item."),
                            new Accessor(field, "rhs."),
                            $"ret.{field.Name}");
                    }
                }
                if (this.HasLoquiBaseObject)
                {
                    fg.AppendLine($"base.FillEqualsMask(item, rhs, ret, include);");
                }
            }
            fg.AppendLine();
        }

        public void GenerateStandardRegistrationDefault(FileGeneration fg, string functionName, string indexAccessor, bool ret, params string[] otherParameters)
        {
            fg.AppendLine("default:");
            using (new DepthWrapper(fg))
            {
                if (this.HasLoquiBaseObject)
                {
                    fg.AppendLine($"{(ret ? "return " : string.Empty)}{BaseClass.RegistrationName}.{functionName}({string.Join(", ", indexAccessor.And(otherParameters))});");
                    if (!ret)
                    {
                        fg.AppendLine("break;");
                    }
                }
                else
                {
                    GenerateIndexOutOfRangeEx(fg, indexAccessor);
                }
            }
        }

        public void GenerateStandardIndexDefault(
            FileGeneration fg,
            string functionName,
            string indexAccessor,
            bool ret,
            bool common,
            params string[] otherParameters)
        {
            fg.AppendLine("default:");
            using (new DepthWrapper(fg))
            {
                if (this.HasLoquiBaseObject)
                {
                    if (common)
                    {
                        fg.AppendLine($"{(ret ? "return " : string.Empty)}{BaseClass.CommonClassName}.{functionName}{this.BaseGenericTypes}({string.Join(", ", indexAccessor.And(otherParameters))});");
                    }
                    else
                    {
                        fg.AppendLine($"{(ret ? "return " : string.Empty)}base.{functionName}({string.Join(", ", indexAccessor.And(otherParameters))});");
                    }
                    if (!ret)
                    {
                        fg.AppendLine("break;");
                    }
                }
                else
                {
                    GenerateIndexOutOfRangeEx(fg, indexAccessor);
                }
            }
        }

        public void GenerateIndexOutOfRangeEx(FileGeneration fg, string indexAccessor)
        {
            fg.AppendLine($"throw new ArgumentException($\"Index is out of range: {{{indexAccessor}}}\");");
        }

        private void GenerateGetNameIndex(FileGeneration fg)
        {
            fg.AppendLine("public static ushort? GetNameIndex(StringCaseAgnostic str)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("switch (str.Upper)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField)
                        {
                            if (string.IsNullOrWhiteSpace(field.Name)) return;
                            fg.AppendLine($"case \"{field.Name.ToUpper()}\":");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNameIndex(fg);
                        }
                    }

                    fg.AppendLine("default:");
                    using (new DepthWrapper(fg))
                    {
                        fg.AppendLine("return null;");
                    }
                }
            }
            fg.AppendLine();
        }

        private async Task AddNamespaces(FileGeneration fg)
        {
            RequiredNamespaces.Add(
                (await Task.WhenAll(this.gen.GenerationModules.Select((tr) => tr.RequiredUsingStatements(this))))
                    .SelectMany(i => i));
            RequiredNamespaces.Add(
                (await Task.WhenAll(this.GenerationInterfaces.Select((tr) => tr.RequiredUsingStatements())))
                    .SelectMany(i => i));
            foreach (var nameSpace in RequiredNamespaces.Union(gen.Namespaces))
            {
                fg.AppendLine($"using {nameSpace};");
            }
            fg.AppendLine();
        }

        protected abstract void GenerateEqualsCode(FileGeneration fg);

        private void GenerateEqualsSection(FileGeneration fg)
        {
            // Generate equals and hash
            if (GenerateEquals)
            {
                using (new RegionWrapper(fg, "Equals and Hash"))
                {
                    fg.AppendLine("public override bool Equals(object obj)");
                    using (new BraceWrapper(fg))
                    {
                        GenerateEqualsCode(fg);
                    }
                    fg.AppendLine();

                    fg.AppendLine($"public bool Equals({this.ObjectName} rhs)");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine("if (rhs == null) return false;");
                        if (this.HasLoquiBaseObject)
                        {
                            fg.AppendLine($"if (!base.Equals(rhs)) return false;");
                        }
                        foreach (var field in this.IterateFields())
                        {
                            if (!HasKeyField() || field.KeyField)
                            {
                                if (field.Bare)
                                {
                                    field.GenerateForEquals(fg, new Accessor(field, "this."), new Accessor(field, "rhs."));
                                }
                                else if (field.IntegrateField)
                                {
                                    if (field.HasBeenSet)
                                    {
                                        fg.AppendLine($"if ({field.HasBeenSetAccessor()} != {field.HasBeenSetAccessor(new Accessor(field, "rhs."))}) return false;");
                                        fg.AppendLine($"if ({field.HasBeenSetAccessor()})");
                                        using (new BraceWrapper(fg))
                                        {
                                            field.GenerateForEquals(fg, new Accessor(field, "this."), new Accessor(field, "rhs."));
                                        }
                                    }
                                    else
                                    {
                                        field.GenerateForEquals(fg, new Accessor(field, "this."), new Accessor(field, "rhs."));
                                    }
                                }
                                else
                                {
                                    field.GenerateForEquals(fg, new Accessor(field, "this."), new Accessor(field, "rhs."));
                                }
                            }
                        }
                        fg.AppendLine("return true;");
                    }
                    fg.AppendLine();

                    fg.AppendLine("public override int GetHashCode()");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine("int ret = 0;");
                        foreach (var field in this.IterateFields())
                        {
                            if (!HasKeyField() || field.KeyField)
                            {
                                if (field.Bare)
                                {
                                    field.GenerateForHash(fg, "ret");
                                }
                                else if (field.IntegrateField)
                                {
                                    if (field.HasBeenSet)
                                    {
                                        fg.AppendLine($"if ({field.HasBeenSetAccessor()})");
                                    }
                                    using (new BraceWrapper(fg, doIt: field.HasBeenSet))
                                    {
                                        field.GenerateForHash(fg, "ret");
                                    }
                                }
                                else
                                {
                                    field.GenerateForHash(fg, "ret");
                                }
                            }
                        }
                        if (this.HasLoquiBaseObject)
                        {
                            fg.AppendLine($"ret = ret.CombineHashCode(base.GetHashCode());");
                        }
                        fg.AppendLine("return ret;");
                    }
                    fg.AppendLine();
                }
                fg.AppendLine();
            }
        }

        private async Task GenerateToStringCode(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "To String"))
            {
                if (GenerateToString)
                {
                    fg.AppendLine($"public override string ToString()");
                    using (new BraceWrapper(fg))
                    {
                        using (var args = new ArgsWrapper(fg,
                            $"return {this.MixInClassName}.ToString"))
                        {
                            args.Add("item: this");
                        }
                    }
                    fg.AppendLine();
                }
                fg.AppendLine();

                using (var args = new FunctionWrapper(fg,
                    $"public{this.FunctionOverride()}void ToString"))
                {
                    args.Add($"FileGeneration fg");
                    args.Add($"string name = null");
                }
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        $"{this.MixInClassName}.ToString"))
                    {
                        args.Add("item: this");
                        args.AddPassArg("name");
                    }
                }
                fg.AppendLine();
            }
        }

        private void GenerateGetHasBeenSetMask(FileGeneration fg)
        {
            fg.AppendLine($"IMask<bool> ILoquiObjectGetter.GetHasBeenSetMask() => this.GetHasBeenSetMask();");
        }

        private async Task GenerateModules(FileGeneration fg)
        {
            if (this.gen.GenerationModules.Count > 0)
            {
                foreach (var transl in gen.GenerationModules)
                {
                    using (new RegionWrapper(fg, transl.RegionString))
                    {
                        await transl.GenerateInClass(this, fg);
                    }
                }
            }
        }

        private void GenerateInterfacesInClass(FileGeneration fg)
        {
            if (this.GenerationInterfaces.Count > 0)
            {
                foreach (var interf in gen.GenerationInterfaces)
                {
                    using (new RegionWrapper(fg, interf.RegionString))
                    {
                        interf.GenerateInClass(this, fg);
                    }
                }
            }
        }

        protected virtual async Task GenerateCopy_ToObject(FileGeneration fg)
        {
            fg.AppendLine($"{this.ProtectedKeyword}{this.FunctionOverride()}object Copy_ToObject(object def = null)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var ret = new {this.ObjectName}();");
                fg.AppendLine($"ret.CopyFieldsFrom_Generic(this, def: def);");
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();
        }

        public virtual void GenerateCopy(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public {this.ObjectName} Copy{this.GetGenericTypes(MaskType.Copy)}",
                wheres: this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, maskTypes: MaskType.Copy)))
            {
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                args.Add($"{this.Interface(getter: true)} def = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return {this.ObjectName}.Copy"))
                {
                    args.Add("this");
                    args.Add("copyMask: copyMask");
                    args.Add("def: def");
                }
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static {this.ObjectName} Copy{this.GetGenericTypes(MaskType.Copy)}",
                wheres: this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, maskTypes: MaskType.Copy)))
            {
                args.Add($"{this.Interface(getter: true)} item");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                args.Add($"{this.Interface(getter: true)} def = null");
            }
            using (new BraceWrapper(fg))
            {
                if (this.Abstract)
                {
                    fg.AppendLine($"{this.ObjectName} ret = ({this.ObjectName})System.Activator.CreateInstance(item.GetType());");
                }
                else
                {
                    fg.AppendLine($"{this.ObjectName} ret;");
                    fg.AppendLine($"if (item.GetType().Equals(typeof({this.ObjectName})))");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"ret = new {this.ObjectName}();");
                    }
                    fg.AppendLine("else");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"ret = ({this.ObjectName})System.Activator.CreateInstance(item.GetType());");
                    }
                }
                using (var args = new ArgsWrapper(fg,
                    $"ret.CopyFieldsFrom{GenerateGenericClause(GenericTypes_Nickname(MaskType.Copy))}"))
                {
                    args.Add("item");
                    args.Add("copyMask: copyMask");
                    args.Add("def: def");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static {this.ObjectName} Copy_ToLoqui{GenerateGenericClause(GenericTypes_Nickname(MaskType.Copy))}",
                wheres: this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, maskTypes: MaskType.Copy)))
            {
                args.Add($"{this.Interface(getter: true)} item");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                args.Add($"{this.Interface(getter: true)} def = null");
            }
            using (new BraceWrapper(fg))
            {
                if (this.Abstract)
                {
                    fg.AppendLine($"{this.ObjectName} ret = ({this.ObjectName})System.Activator.CreateInstance(item.GetType());");
                }
                else
                {
                    fg.AppendLine($"{this.ObjectName} ret;");
                    fg.AppendLine($"if (item.GetType().Equals(typeof({this.ObjectName})))");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"ret = new {this.ObjectName}() as {this.ObjectName};");
                    }
                    fg.AppendLine("else");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"ret = ({this.ObjectName})System.Activator.CreateInstance(item.GetType());");
                    }
                }
                using (var args = new ArgsWrapper(fg,
                    $"ret.CopyFieldsFrom{GenerateGenericClause(GenericTypes_Nickname(MaskType.Copy))}"))
                {
                    args.Add("item");
                    args.Add("copyMask: copyMask");
                    args.Add("def: def");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();
        }

        protected virtual async Task GenerateClearMixIn(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static void Clear{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.ISetter).ToArray()))
            {
                args.Add($"this {this.Interface()} item");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"(({this.CommonClass})item.CommonInstance).Clear"))
                {
                    args.AddPassArg("item");
                }
            }
            fg.AppendLine();
        }

        protected void GenerateClear(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public{this.FunctionOverride()}void Clear"))
            {
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.CommonClass}.Instance.Clear(this);");
            }
            fg.AppendLine();
        }

        protected virtual async Task GenerateClearCommon(FileGeneration fg)
        {
            fg.AppendLine("partial void ClearPartial();");
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public virtual void Clear{this.GetGenericTypes(MaskType.Normal)}",
                GenerateWhereClauses(LoquiInterfaceType.ISetter).ToArray()))
            {
                args.Add($"{this.Interface()} item");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"ClearPartial();");
                foreach (var field in this.IterateFields())
                {
                    if (field.ReadOnly) continue;
                    field.GenerateClear(fg, new Accessor(field, "item."));
                }
                if (this.HasLoquiBaseObject)
                {
                    fg.AppendLine($"base.Clear(item);");
                }
            }
            fg.AppendLine();

            foreach (var baseObj in this.BaseClassTrail())
            {
                using (var args = new FunctionWrapper(fg,
                    $"public override void Clear"))
                {
                    args.Add($"{baseObj.Interface()} item");
                }
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        "Clear"))
                    {
                        args.Add($"item: ({this.Interface()})item");
                    }
                }
                fg.AppendLine();
            }
        }

        private void GenerateClear(FileGeneration fg, string accessor)
        {
        }

        protected virtual void GenerateGenericCreate(FileGeneration fg)
        {
            if (!this.Abstract)
            {
                fg.AppendLine($"public{this.NewOverride()}static {this.ObjectName} {Loqui.Internal.Constants.CREATE_FUNC_NAME}(IEnumerable<KeyValuePair<ushort, object>> fields)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"var ret = new {this.ObjectName}();");
                    fg.AppendLine($"foreach (var pair in fields)");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"CopyInInternal_{this.Name}(ret, pair);");
                    }
                    fg.AppendLine("return ret;");
                }
                fg.AppendLine();
            }

            fg.AppendLine($"protected{this.NewOverride()}static void CopyInInternal_{this.Name}({this.ObjectName} obj, KeyValuePair<ushort, object> pair)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"if (!EnumExt.TryParse(pair.Key, out {this.FieldIndexName} enu))");
                using (new BraceWrapper(fg))
                {
                    if (this.HasLoquiBaseObject)
                    {
                        fg.AppendLine($"CopyInInternal_{this.BaseClass.Name}(obj, pair);");
                    }
                    else
                    {
                        fg.AppendLine("throw new ArgumentException($\"Unknown index: {pair.Key}\");");
                    }
                }
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.Derivative) continue;
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateSetNth(
                                fg,
                                accessorPrefix: $"obj",
                                rhsAccessorPrefix: $"({field.SetToName})pair.Value",
                                internalUse: true);
                        }
                    }
                    fg.AppendLine("default:");
                    using (new DepthWrapper(fg))
                    {
                        fg.AppendLine("throw new ArgumentException($\"Unknown enum type: {enu}\");");
                    }
                }
            }

            if (this.GenerateNthReflections)
            {
                fg.AppendLine($"public static void {Loqui.Internal.Constants.COPYIN_FUNC_NAME}(IEnumerable<KeyValuePair<ushort, object>> fields, {this.ObjectName} obj)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine("ILoquiObjectExt.CopyFieldsIn(obj, fields, def: null, skipProtected: false);");
                }
                fg.AppendLine();
            }
        }

        private void GenerateIsProtected(FileGeneration fg)
        {
            fg.AppendLine("public static bool IsProtected(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var trues = IterateFieldIndices().Where((i) => i.Field.ReadOnly);
                    var falses = IterateFieldIndices().Where((i) => !i.Field.ReadOnly);
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "IsProtected", "index", true);
                }
            }
            fg.AppendLine();
        }

        public void GenerateExceptionCatcher(FileGeneration fg, TypeGeneration field, string errorMaskAccessor, string enumAccessor)
        {
            fg.AppendLine("catch (Exception ex)");
            fg.AppendLine($"when ({errorMaskAccessor} != null)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{errorMaskAccessor}.ReportException(ex);");
            }
            fg.AppendLine("finally");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("errorMask?.PopIndex();");
            }
        }
        #endregion

        private async Task GenerateTranslations(FileGeneration fg)
        {
            if (this.gen.GenerationModules.Count == 0) return;
            using (new RegionWrapper(fg, "Modules"))
            {
                foreach (var translGen in this.gen.GenerationModules)
                {
                    using (new RegionWrapper(fg, translGen.RegionString))
                    {
                        await translGen.GenerateInVoid(this, fg);
                    }
                }
            }

            await Task.WhenAll(this.gen.GenerationModules
                .Select((g) => g.MiscellaneousGenerationActions(this)));
        }

        private void GenerateLoquiInterfaces(FileGeneration fg)
        {
            if (this.gen.GenerationModules.Count == 0) return;
            using (new RegionWrapper(fg, "Loqui Interfaces"))
            {
                foreach (var interfGen in this.GenerationInterfaces)
                {
                    using (new RegionWrapper(fg, interfGen.RegionString))
                    {
                        interfGen.Generate(this, fg);
                    }
                }
            }
        }

        public bool HasLoquiInterface<T>()
            where T : GenerationInterface
        {
            return this.GenerationInterfaces.Any((i) => i.GetType().Equals(typeof(T)));
        }

        public string GetMaskString(string t)
        {
            if (t.Equals("Exception"))
            {
                return this.Mask(MaskType.Error);
            }
            else
            {
                var str = this.Name;
                str += "_Mask";
                str += $"<{t}>";
                return str;
            }
        }

        public virtual async Task Resolve()
        {
            foreach (var gen in this.Generics.Values)
            {
                gen.Resolve(this);
            }

            await Task.WhenAll(this.IterateFields().ToList().Select((f) => f.Resolve()));

            if (this.HasRaisedPropertyChanged)
            {
                this.RequiredNamespaces.Add("System.ComponentModel");
                this.Interfaces.Add(nameof(INotifyPropertyChanged));
            }

            if (this.HasLoquiBaseObject)
            {
                AddBaseClassNamespaces(this);

                foreach (var baseGen in this.BaseClass.Generics)
                {
                    this.Generics.Add(baseGen.Key, baseGen.Value.Copy());
                    this.BaseGenerics[baseGen.Key] = baseGen.Key;
                }

                foreach (var baseGeneric in Node.Elements(XName.Get("BaseGeneric", LoquiGenerator.Namespace)))
                {
                    var genName = baseGeneric.GetAttribute("name");
                    var whereElem = baseGeneric.Elements(XName.Get("Where", LoquiGenerator.Namespace)).ToArray();
                    var definedElem = baseGeneric.Element(XName.Get("Defined", LoquiGenerator.Namespace));
                    if (whereElem.Any()
                        && definedElem != null)
                    {
                        throw new ArgumentException("Cannot define both Where and Defined nodes.");
                    }
                    if (whereElem.Any())
                    {
                        this.BaseGenerics[genName] = genName;
                        this.Generics[genName].Add(whereElem.Select((w) => w.Value));
                    }
                    else if (definedElem != null)
                    {
                        this.BaseGenerics[genName] = definedElem.Value;
                        this.Generics.Remove(genName);
                    }
                    else
                    {
                        throw new ArgumentException("Need to define Where or Defined node.");
                    }
                }
            }

            await Task.WhenAll(this.gen.GenerationModules.Select((mod) => mod.Resolve(this)));
        }

        private void AddBaseClassNamespaces(ObjectGeneration obj)
        {
            if (!obj.HasLoquiBaseObject) return;
            this.RequiredNamespaces.Add(obj.BaseClass.Namespace);
            this.RequiredNamespaces.Add(obj.BaseClass.InternalNamespace);
            AddBaseClassNamespaces(obj.BaseClass);
        }

        public void RegenerateAndStampSourceXML()
        {
            XDocument doc;
            using (var stream = new FileStream(this.SourceXMLFile.FullName, FileMode.Open))
            {
                doc = XDocument.Load(stream);
            }
            bool modified = false;

            var LoquiNode = doc.Element(XName.Get("Loqui", LoquiGenerator.Namespace));
            foreach (var obj in LoquiNode.Elements(XName.Get("Object", LoquiGenerator.Namespace))
                .And(LoquiNode.Elements(XName.Get("Struct", LoquiGenerator.Namespace))))
            {
                var name = obj.GetAttribute("name");
                if (name.Equals(this.Name))
                {
                    if (obj.GetAttribute("GUID") == null)
                    {
                        var guidAttr = new XAttribute("GUID", this.GUID.ToString());
                        obj.Add(guidAttr);
                        modified = true;
                    }
                    if (obj.GetAttribute("ID") == null)
                    {
                        var guidAttr = new XAttribute("ID", this.ID.ToString());
                        obj.Add(guidAttr);
                        modified = true;
                    }
                    break;
                }
            }

            if (!modified) return;

            using (var writer = new XmlTextWriter(
                new FileStream(this.SourceXMLFile.FullName, FileMode.Create), Encoding.ASCII))
            {
                writer.Formatting = Formatting.Indented;
                writer.Indentation = 2;
                doc.WriteTo(writer);
            }
        }

        public string Mask_Specified(MaskType type, GenericSpecification specifications)
        {
            return $"{this.Mask_BasicName(type)}{GenerateGenericClause(GenericTypes_Nickname(type, specifications.Specifications.ToArray()))}";
        }

        public string MaskNickname(string name, MaskType maskType)
        {
            switch (maskType)
            {
                case MaskType.Normal:
                    return name;
                case MaskType.Error:
                    return $"{name}_{MaskModule.ErrMaskNickname}";
                case MaskType.Copy:
                    return $"{name}_{MaskModule.CopyMaskNickname}";
                case MaskType.Translation:
                    return $"{name}_{MaskModule.TranslationMaskNickname}";
                default:
                    throw new NotImplementedException();
            }
        }

        public string SpecifyGeneric(MaskType maskType, KeyValuePair<string, GenericDefinition> g, params KeyValuePair<string, string>[] specifications)
        {
            var specification = specifications.FirstOrDefault((spec) => spec.Key == g.Key);
            if (specification.Value == null)
            {
                return MaskNickname(g.Key, maskType);
            }
            else
            {
                var nameKey = ObjectNamedKey.Factory(specification.Value, this.ProtoGen.Protocol);
                if (!this.ProtoGen.Gen.ObjectGenerationsByObjectNameKey.TryGetValue(
                   nameKey,
                   out var targetObj))
                {
                    throw new ArgumentException($"{nameKey} can not be located.");
                }
                return targetObj.Mask(maskType);
            }
        }

        public IEnumerable<string> GenericTypes_Nickname(MaskType maskType, params KeyValuePair<string, string>[] specifications)
        {
            return Generics
                .Where(g => g.Value.Loqui)
                .Select((g) =>
                {
                    return SpecifyGeneric(maskType, g, specifications);
                });
        }

        public IEnumerable<string> BaseGenericTypes_Nickname(MaskType maskType, params KeyValuePair<string, string>[] specifications)
        {
            return Generics
                .Where((g) => g.Value.BaseObjectGeneration != null)
                .Where((g) => this.BaseGenerics.ContainsKey(g.Key))
                .Select((g) =>
                {
                    return SpecifyGeneric(maskType, g, specifications);
                });
        }

        public string Mask_BasicName(MaskType type)
        {
            switch (type)
            {
                case MaskType.Normal:
                    return $"{this.Name}_Mask";
                case MaskType.Error:
                    return $"{this.Name}_ErrorMask";
                case MaskType.Copy:
                    return $"{this.Name}_CopyMask";
                case MaskType.Translation:
                    return $"{this.Name}_TranslationMask";
                default:
                    throw new NotImplementedException();
            }
        }

        public string Mask(MaskType type)
        {
            switch (type)
            {
                case MaskType.Error:
                    return $"{this.Mask_BasicName(MaskType.Error)}{GetGenericTypes(MaskType.Error)}";
                case MaskType.Copy:
                    return $"{this.Mask_BasicName(MaskType.Copy)}{GetGenericTypes(MaskType.Copy)}";
                case MaskType.Translation:
                    return $"{this.Mask_BasicName(MaskType.Translation)}{GetGenericTypes(MaskType.Translation)}";
                case MaskType.Normal:
                default:
                    throw new NotImplementedException();
            }
        }

        public bool CanAssume()
        {
            return !Generics.Any(g => g.Value.Loqui && g.Value.BaseObjectGeneration == null);
        }

        public IEnumerable<string> GenericTypes_Assumed(MaskType type, bool onlyAssumeSubclass = false)
        {
            return Generics
                .Where(g => g.Value.Loqui)
                .Select((g) =>
                {
                    if (g.Value.BaseObjectGeneration != null)
                    {
                        if (!onlyAssumeSubclass || !this.BaseGenerics.ContainsKey(g.Key))
                        {
                            return g.Value.BaseObjectGeneration.Mask(type);
                        }
                        else
                        {
                            return SpecifyGeneric(type, g);
                        }
                    }
                    else
                    {
                        switch (type)
                        {
                            case MaskType.Error:
                                return nameof(ErrorMaskPlaceholder);
                            case MaskType.Copy:
                            case MaskType.Normal:
                            default:
                                throw new NotImplementedException();
                        }
                    }
                });
        }

        public string GenericClause_Assumed(MaskType type, bool onlyAssumeSubclass = false)
        {
            return GenerateGenericClause(GenericTypes_Assumed(type, onlyAssumeSubclass));
        }

        public string Mask_GenericAssumed(MaskType type, bool onlyAssumeSubclass = false)
        {
            return $"{this.Mask_BasicName(type)}{GenericClause_Assumed(type, onlyAssumeSubclass)}";
        }

        public string Mask_Unspecified(MaskType type)
        {
            return $"{this.Mask_BasicName(type)}{GenerateGenericClause(Generics.Where((g) => g.Value.BaseObjectGeneration != null || g.Value.Loqui).Select((g) => string.Empty))}";
        }

        public string BaseMask_GenericClausesAssumed(MaskType type)
        {
            return GenerateGenericClause(Generics.SelectWhere((g) =>
            {
                if (g.Value.BaseObjectGeneration != null)
                {
                    return TryGet<string>.Succeed(g.Value.BaseObjectGeneration.Mask(type));
                }
                else if (g.Value.Loqui)
                {
                    return TryGet<string>.Succeed("IErrorMask");
                }
                else
                {
                    return TryGet<string>.Failure;
                }
            }));
        }

        public string GetBaseMask_GenericTypes(MaskType type)
        {
            if (!this.HasLoquiBaseObject)
            {
                return GetGenericTypes(type);
            }
            return GenerateGenericClause(Generics
                .Where((g) => g.Value.Loqui)
                .Where((g) => this.BaseGenerics.ContainsKey(g.Key))
                .Select((g) =>
                {
                    return SpecifyGeneric(type, g);
                }));
        }

        public IEnumerable<TypeGeneration> IterateFields(
            bool nonIntegrated = false,
            SetMarkerType.ExpandSets expandSets = SetMarkerType.ExpandSets.True,
            bool includeBaseClass = false)
        {
            return IterateFieldIndices(
                nonIntegrated: nonIntegrated,
                expandSets: expandSets,
                includeBaseClass: includeBaseClass).Select((f) => f.Field);
        }

        public IEnumerable<(int PublicIndex, int InternalIndex, TypeGeneration Field)> IterateFieldIndices(
            bool nonIntegrated = false,
            SetMarkerType.ExpandSets expandSets = SetMarkerType.ExpandSets.True,
            bool includeBaseClass = false)
        {
            if (includeBaseClass && this.HasLoquiBaseObject)
            {
                foreach (var item in this.BaseClass.IterateFieldIndices(
                    nonIntegrated: nonIntegrated,
                    expandSets: expandSets,
                    includeBaseClass: includeBaseClass))
                {
                    yield return item;
                }
            }
            int i = this.StartingIndex;
            for (int j = 0; j < this.Fields.Count; j++)
            {
                var field = this.Fields[j];
                if (!field.IntegrateField)
                {
                    if (field is SetMarkerType set)
                    {
                        switch (expandSets)
                        {
                            case SetMarkerType.ExpandSets.False:
                                continue;
                            case SetMarkerType.ExpandSets.FalseAndInclude:
                                yield return (-1, j, field);
                                continue;
                            case SetMarkerType.ExpandSets.True:
                            case SetMarkerType.ExpandSets.TrueAndInclude:
                                int k = 0;
                                foreach (var subField in set.IterateFields(
                                    nonIntegrated: nonIntegrated,
                                    expandSets: expandSets))
                                {
                                    yield return (subField.Index + i, j, subField.Field);
                                    k++;
                                }
                                i += k;
                                break;
                            default:
                                throw new NotImplementedException();
                        }
                        if (expandSets == SetMarkerType.ExpandSets.TrueAndInclude)
                        {
                            yield return (-1, j, field);
                        }
                    }
                    else if (nonIntegrated)
                    {
                        yield return (-1, j, field);
                    }
                }
                else
                {
                    yield return (i++, j, field);
                }
            }
        }

        public virtual async Task<OverrideType> GetFunctionOverrideType(Func<ClassGeneration, Task<bool>> tester)
        {
            return OverrideType.None;
        }

        public virtual OverrideType GetFunctionOverrideType()
        {
            return OverrideType.None;
        }

        public async Task<string> FunctionOverride(Func<ClassGeneration, Task<bool>> tester)
        {
            switch (await GetFunctionOverrideType(tester))
            {
                case OverrideType.None:
                    return " ";
                case OverrideType.HasBase:
                    return " override ";
                case OverrideType.OnlyHasDerivative:
                    return " virtual ";
                default:
                    throw new NotImplementedException();
            }
        }

        public string FunctionOverride(bool doIt = true)
        {
            if (!doIt) return " ";
            switch (GetFunctionOverrideType())
            {
                case OverrideType.None:
                    return " ";
                case OverrideType.HasBase:
                    return " override ";
                case OverrideType.OnlyHasDerivative:
                    return " virtual ";
                default:
                    throw new NotImplementedException();
            }
        }

        public IEnumerable<ClassGeneration> BaseClassTrail()
        {
            if (!this.HasLoquiBaseObject) yield break;
            yield return this.BaseClass;
            foreach (var ret in this.BaseClass.BaseClassTrail())
            {
                yield return ret;
            }
        }

        public async Task<IEnumerable<ObjectGeneration>> EntireClassTree()
        {
            var processedObjs = new HashSet<ObjectGeneration>();
            await EntireClassTree(processedObjs);
            return processedObjs;
        }

        private async Task EntireClassTree(HashSet<ObjectGeneration> processedObjs)
        {
            if (processedObjs.Contains(this)) return;
            processedObjs.Add(this);
            foreach (var subObj in await this.InheritingObjects())
            {
                await subObj.EntireClassTree(processedObjs);
            }
            if (this.HasLoquiBaseObject)
            {
                await this.BaseClass.EntireClassTree(processedObjs);
            }
        }

        public bool TestTrueAndNotBaseClass(Func<ObjectGeneration, bool> test)
        {
            return test(this) && !this.BaseClassTrail().Any(b => test(b));
        }

        public bool TestTrueForAnyInClassChain(Func<ObjectGeneration, bool> test)
        {
            return test(this) || this.BaseClassTrail().Any(b => test(b));
        }

        public override string ToString()
        {
            return this.Name;
        }

        public void MarkFailure(Exception ex)
        {
            this._directlyInheritingObjectsTcs.TrySetException(ex);
            this.LoadingCompleteTask.TrySetException(ex);
            this.WiredBaseClassTCS.TrySetException(ex);
        }

        public string[] GenericTypeMaskWheres(LoquiInterfaceType type, params MaskType[] maskTypes)
        {
            return maskTypes.SelectMany(
                (maskType) =>
                {
                    switch (maskType)
                    {
                        case MaskType.Normal:
                            return GenerateWhereClauses(type);
                        default:
                            break;
                    }
                    return Generics
                        .SelectWhere((g) =>
                        {
                            List<string> strs = new List<string>();
                            if (g.Value.BaseObjectGeneration != null)
                            {
                                strs.Add($"{g.Value.BaseObjectGeneration.Mask(maskType)}");
                            }
                            else if (g.Value.Loqui)
                            {
                                strs.Add("class");
                            }
                            else
                            {
                                return TryGet<string>.Failure;
                            }
                            if (maskType == MaskType.Error)
                            {
                                strs.Add($"IErrorMask<{MaskNickname(g.Key, maskType)}>");
                            }
                            if (maskType == MaskType.Translation)
                            {
                                strs.Add($"{nameof(ITranslationMask)}");
                            }
                            strs.Add("new()");
                            return TryGet<string>.Succeed($"where {g.Key}_{MaskModule.MaskNickname(maskType)} : {(string.Join(", ", strs))}");
                        });
                }).ToArray();
        }

        public string GetGenericTypes(params MaskType[] maskTypes)
        {
            return GenerateGenericClause(
                maskTypes.Select(
                    (maskType) =>
                    {
                        switch (maskType)
                        {
                            case MaskType.Normal:
                                return Generics.Select((g) => g.Key);
                            case MaskType.Error:
                            case MaskType.Copy:
                            case MaskType.Translation:
                                return GenericTypes_Nickname(maskType);
                            default:
                                throw new NotImplementedException();
                        }
                    }).ToArray());
        }

        public string GetBaseGenericTypes(params MaskType[] maskTypes)
        {
            return GenerateGenericClause(
                maskTypes.Select(
                    (maskType) =>
                    {
                        switch (maskType)
                        {
                            case MaskType.Normal:
                                return BaseGenerics.Select((g) => g.Key);
                            case MaskType.Error:
                            case MaskType.Copy:
                            case MaskType.Translation:
                                return BaseGenericTypes_Nickname(maskType);
                            default:
                                throw new NotImplementedException();
                        }
                    }).ToArray());
        }

        public string GetTypeName(LoquiInterfaceType type)
        {
            switch (type)
            {
                case LoquiInterfaceType.Direct:
                    return this.Name;
                case LoquiInterfaceType.IGetter:
                    return this.Interface(getter: true, internalInterface: this.HasInternalInterface);
                case LoquiInterfaceType.ISetter:
                    return this.Interface(getter: false, internalInterface: this.HasInternalInterface);
                default:
                    throw new NotImplementedException();
            }
        }

        public string Interface(bool getter = false, bool? internalInterface = null)
        {
            return Interface(
                genericTypes: this.GetGenericTypes(MaskType.Normal),
                getter: getter,
                internalInterface: internalInterface ?? this.HasInternalInterface);
        }

        public string Interface(string genericTypes, bool getter = false, bool internalInterface = false)
        {
            var ret = InterfaceNoGenerics(
                getter: getter,
                internalInterface: internalInterface);
            return $"{ret}{genericTypes}";
        }

        public string InterfaceNoGenerics(bool getter = false, bool internalInterface = false)
        {
            return $"I{this.Name}{(internalInterface ? "Internal" : null)}{(getter ? "Getter" : null)}";
        }

        public async Task<IEnumerable<string>> GetApplicableInterfaces(LoquiInterfaceType type)
        {
            return (await Task.WhenAll(this.gen.GenerationModules
                        .Select((tr) => tr.Interfaces(this))))
                .SelectMany(i => i)
                .Where(i => i.Location == type)
                .Select(i => i.Interface);
        }
    }
}
