using Noggog;
using Noggog.Notifying;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;

namespace Loqui.Generation
{
    public abstract class ObjectGeneration
    {
        public const string AUTOGENERATED = "LoquiGenerated";
        public string Name;
        public string Namespace;
        public string InternalNamespace => $"{Namespace}.Internals";
        public string FullName => $"{Namespace}.{Name}";
        public abstract bool Abstract { get; }
        public DisabledLevel Disabled { get; protected set; }
        public bool GenerateClass { get; protected set; } = true;
        public bool GenerateEquals { get; protected set; } = true;
        public bool GenerateToString { get; protected set; } = true;
        public bool GeneratePublicBasicCtor { get; protected set; } = true;
        public abstract bool NotifyingDefault { get; }
        public abstract bool HasBeenSetDefault { get; }
        public LoquiInterfaceType InterfaceTypeDefault;
        public bool ReadOnlyDefault;
        public bool DerivativeDefault;
        public bool RaisePropertyChangedDefault;
        public bool HasRaisedPropertyChanged => this.IterateFields().Any((f) => f.RaisePropertyChanged);
        public int StartingIndex => this.HasBaseObject ? this.BaseClass.StartingIndex + this.BaseClass.IterateFields().Count() : 0;
        public ObjectGeneration BaseClass;
        public bool HasBaseObject => BaseClass != null;
        public bool HasLoquiGenerics => this.Generics.Any((g) => g.Value.BaseObjectGeneration != null);
        public bool HasNewGenerics => this.HasBaseObject && this.Generics.Any((g) => !this.BaseGenerics.ContainsKey(g.Key));
        public bool IsTopClass => BaseClass == null;
        public bool ExportWithIGetter = true;
        public HashSet<string> Interfaces = new HashSet<string>();
        public Dictionary<string, GenericDefinition> Generics = new Dictionary<string, GenericDefinition>();
        public string EmptyGenerics => (this.Generics.Count > 0 ? $"<{string.Join(",", this.Generics.Select((g) => string.Empty))}>" : string.Empty);
        public Dictionary<string, string> BaseGenerics = new Dictionary<string, string>();
        public virtual string NewOverride => " ";
        public virtual string ProtectedKeyword => "protected";
        public ushort? ID;
        public Guid GUID;
        public ushort Version = 0;
        public XElement Node;
        public ObjectKey Key => new ObjectKey(ProtoGen.Protocol, ID.Value, Version);
        public string FileName => $"{this.Name}_{AUTOGENERATED}.cs";

        // String properties
        public string ObjectName => $"{this.Name}{GenericTypes}";
        public string ExtName => $"{Name}Ext";
        public string InterfaceStr => InterfaceStr_Generic(this.GenericTypes);
        public string RegistrationName => $"{this.Name}_Registration";
        public string Getter_InterfaceStr_NoGenerics => $"I{Name}Getter";
        public string Setter_InterfaceStr_NoGenerics => $"I{this.Name}";
        public string Getter_InterfaceStr => $"{this.Getter_InterfaceStr_NoGenerics}{GenericTypes}";
        public string GenericTypes => GenerateGenericClause(Generics.Select((g) => g.Key));
        public string[] GenericTypes_ErrorMaskWheres => Generics.Where((g) => g.Value.BaseObjectGeneration != null).Select((g) => $"where {g.Key}_{MaskModule.ErrMaskNickname} : {g.Value.BaseObjectGeneration.Mask(MaskType.Error)}, IErrorMask<{g.Key}_{MaskModule.ErrMaskNickname}>, new()").ToArray();
        public string[] GenericTypes_CopyMaskWheres => Generics.Where((g) => g.Value.BaseObjectGeneration != null).Select((g) => $"where {g.Key}_{MaskModule.CopyMaskNickname} : {g.Value.BaseObjectGeneration.Mask(MaskType.Copy)}, new()").ToArray();
        public string[] All_Wheres => this.GenerateWhereClauses().And(GenericTypes_ErrorMaskWheres).And(GenericTypes_CopyMaskWheres).ToArray();
        public string BaseGenericTypes => GenerateGenericClause(BaseGenerics.Select((g) => g.Value));
        public string BaseClassName => $"{this.BaseClass.Name}{this.BaseGenericTypes}";
        public string BaseGenericTypes_ErrMask_CopyMask => GenerateGenericClause(BaseGenerics.Where((g) => this.BaseGenerics.ContainsKey(g.Key)).Select((g) => g.Value).And(BaseGenericTypes_Nickname(MaskType.Error)).And(BaseGenericTypes_Nickname(MaskType.Copy)));
        public string GenericTypes_CopyMask => $"{GenerateGenericClause(Generics.Select((g) => g.Key).And(GenericTypes_Nickname(MaskType.Copy)))}";
        public string GenericTypes_SubTypeAssumedErrMask => $"{GenerateGenericClause(Generics.Select((g) => g.Key).And(GenericTypes_Assumed(MaskType.Error, onlyAssumeSubclass: true)))}";
        public string GenericTypes_AssumedErrMask_CopyMask => $"{GenerateGenericClause(Generics.Select((g) => g.Key).And(GenericTypes_Assumed(MaskType.Error)).And(GenericTypes_Nickname(MaskType.Copy)))}";
        public string GenericTypes_ErrMask_CopyMask => $"{GenerateGenericClause(Generics.Select((g) => g.Key).And(GenericTypes_Nickname(MaskType.Error)).And(GenericTypes_Nickname(MaskType.Copy)))}";
        public string GenericTypes_ErrMask => $"{GenerateGenericClause(Generics.Select((g) => g.Key).And(GenericTypes_Nickname(MaskType.Error)))}";
        public string FieldIndexName => $"{this.Name}_FieldIndex";
        public string ProtocolDefinitionName => $"{this.ProtoGen.ProtocolDefinitionName}";
        public string ExtCommonName => $"{Name}Common";

        public string InterfaceStr_Generic(string genericTypes) => $"{this.Setter_InterfaceStr_NoGenerics}{genericTypes}";

        public string Getter_InterfaceStr_Generic(string genericTypes) => $"{Getter_InterfaceStr_NoGenerics}{genericTypes}";

        public DirectoryInfo TargetDir { get; private set; }
        public FileInfo SourceXMLFile { get; private set; }
        protected LoquiGenerator gen;
        public ProtocolGeneration ProtoGen;
        public HashSet<string> RequiredNamespaces = new HashSet<string>();
        public List<GenerationInterface> GenerationInterfaces = new List<GenerationInterface>();
        public List<TypeGeneration> Fields = new List<TypeGeneration>();
        public IEnumerable<TypeGeneration> AllFields => this.HasBaseObject ? this.Fields.And(this.BaseClass?.AllFields) : this.Fields;
        public Dictionary<FilePath, ProjItemType> GeneratedFiles = new Dictionary<FilePath, ProjItemType>();
        public Dictionary<object, object> CustomData = new Dictionary<object, object>();

        // Task Coordinators
        protected TaskCompletionSource<List<ObjectGeneration>> _directlyInheritingObjectsTcs = new TaskCompletionSource<List<ObjectGeneration>>();
        protected Task<List<ObjectGeneration>> _directlyInheritingObjects => _directlyInheritingObjectsTcs.Task;
        public async Task<IEnumerable<ObjectGeneration>> InheritingObjects()
        {
            List<ObjectGeneration> ret = new List<ObjectGeneration>();
            var objs = await _directlyInheritingObjects;
            ret.AddRange(objs);
            ret.AddRange((await Task.WhenAll(
                objs.Select(async (o) => await o.InheritingObjects()))).SelectMany((i) => i));
            return ret;
        }
        public TaskCompletionSource LoadingCompleteTask = new TaskCompletionSource();
        protected TaskCompletionSource WiredBaseClassTCS = new TaskCompletionSource();
        public Task WiredBaseClassTask => WiredBaseClassTCS.Task;

        public ObjectGeneration(LoquiGenerator gen, ProtocolGeneration protoGen, FileInfo sourceFile)
        {
            this.gen = gen;
            this.ProtoGen = protoGen;
            this.TargetDir = sourceFile.Directory;
            this.SourceXMLFile = sourceFile;
            this.InterfaceTypeDefault = this.ProtoGen.InterfaceTypeDefault;
            this.ReadOnlyDefault = this.ProtoGen.ProtectedDefault;
            this.DerivativeDefault = this.ProtoGen.DerivativeDefault;
            this.RaisePropertyChangedDefault = this.ProtoGen.RaisePropertyChangedDefault;
            this.Disabled = DisabledLevel.Enabled;

            RequiredNamespaces.Add("System");
            RequiredNamespaces.Add("System.Collections");
            RequiredNamespaces.Add("System.Collections.Generic");
            RequiredNamespaces.Add("System.Linq");
            RequiredNamespaces.Add("System.Text");
            RequiredNamespaces.Add("Loqui");
            RequiredNamespaces.Add("Noggog");
            RequiredNamespaces.Add("Noggog.Notifying");
        }

        public virtual async Task Load()
        {
            Node.TransferAttribute<bool>(Constants.GENERATE_CLASS, (i) => GenerateClass = i);
            Node.TransferAttribute<bool>(Constants.GENERATE_EQUALS, (i) => GenerateEquals = i);
            Node.TransferAttribute<bool>(Constants.GENERATE_TO_STRING, (i) => GenerateToString = i);
            Node.TransferAttribute<bool>(Constants.PUBLIC_CTOR, (i) => GeneratePublicBasicCtor = i);
            Node.TransferAttribute<ushort>(Constants.VERSION, (i) => Version = i);
            Node.TransferAttribute<bool>(Constants.IGETTER_EXPORT, (i) => this.ExportWithIGetter = i);
            Node.TransferAttribute<LoquiInterfaceType>(Constants.INTERFACE_TYPE_DEFAULT, (i) => this.InterfaceTypeDefault = i);
            Node.TransferAttribute<bool>(Constants.PROTECTED_DEFAULT, (i) => this.ReadOnlyDefault = i);
            Node.TransferAttribute<bool>(Constants.DERIVATIVE_DEFAULT, (i) => this.DerivativeDefault = i);
            Node.TransferAttribute<bool>(Constants.RAISEPROPERTYCHANGED_DEFAULT, (i) => this.RaisePropertyChangedDefault = i);
            Node.TransferAttribute<DisabledLevel>(Constants.DISABLE, (i) => this.Disabled = i);

            var namespacesNode = Node.Element(XName.Get(Constants.NAMESPACES, LoquiGenerator.Namespace));
            if (namespacesNode != null)
            {
                foreach (var node in namespacesNode.Elements())
                {
                    if (!string.IsNullOrWhiteSpace(node.Value))
                    {
                        this.RequiredNamespaces.Add(node.Value);
                    }
                }
            }
            RequiredNamespaces.Add(InternalNamespace);

            foreach (var genNode in Node.Elements(XName.Get(Constants.GENERIC, LoquiGenerator.Namespace)))
            {
                var generic = new GenericDefinition();
                generic.Name = genNode.GetAttribute(Constants.NAME);
                var baseClass = genNode.Element(XName.Get(Constants.BASE_CLASS, LoquiGenerator.Namespace));
                if (baseClass != null)
                {
                    generic.Add(baseClass.Value);
                }
                foreach (var where in genNode.Elements(XName.Get(Constants.WHERE, LoquiGenerator.Namespace)))
                {
                    generic.Add(where.Value);
                }
                this.Generics[generic.Name] = generic;
            }

            foreach (var interfNode in Node.Elements(XName.Get(Constants.INTERFACE, LoquiGenerator.Namespace)))
            {
                Interfaces.Add(interfNode.Value);
            }

            var fieldsNode = Node.Element(XName.Get(Constants.FIELDS, LoquiGenerator.Namespace));
            if (fieldsNode != null)
            {
                foreach (var fieldNode in fieldsNode.Elements())
                {
                    var typeGen = await LoadField(fieldNode, requireName: true);
                    if (typeGen.Succeeded)
                    {
                        Fields.Add(typeGen.Value);
                    }
                }
            }

            foreach (var interf in this.GenerationInterfaces)
            {
                interf.Modify(this);
            }

            List<ObjectGeneration> directlyInheritingObjs = new List<ObjectGeneration>();
            await Task.WhenAll(
                this.ProtoGen.Gen.ObjectGenerations.Select(
                    async (obj) =>
                    {
                        await obj.WiredBaseClassTask;
                        if (!obj.HasBaseObject) return;
                        if (!object.ReferenceEquals(obj.BaseClass, this)) return;
                        directlyInheritingObjs.Add(obj);
                    }));
            this._directlyInheritingObjectsTcs.SetResult(directlyInheritingObjs);

            await Task.WhenAll(
                this.gen.GenerationModules.Select((m) => m.PostLoad(this)));
        }

        public async Task<TryGet<TypeGeneration>> LoadField(XElement fieldNode, bool requireName, bool throwException = true, bool setDefaults = true)
        {
            if (fieldNode.NodeType == System.Xml.XmlNodeType.Comment)
            {
                return TryGet<TypeGeneration>.Failure;
            }

            if (!gen.TryGetTypeGeneration(fieldNode.Name.LocalName, out var typeGen))
            {
                if (throwException)
                {
                    throw new ArgumentException($"Unknown field type: {fieldNode.Name.LocalName}");
                }
                else
                {
                    return TryGet<TypeGeneration>.Failure;
                }
            }

            typeGen.SetObjectGeneration(this, setDefaults: setDefaults);
            await typeGen.Load(fieldNode, requireName);
            await LoadField(typeGen, fieldNode, add: false);
            return TryGet<TypeGeneration>.Succeed(typeGen);
        }

        public async Task LoadField(TypeGeneration typeGen, XElement fieldNode = null, bool add = true)
        {
            if (this.Fields.Any((f) => f.Name?.Equals(typeGen.Name) ?? false))
            {
                throw new ArgumentException("Cannot have two fields with the same name.");
            }
            if (add)
            {
                typeGen.SetObjectGeneration(this, setDefaults: true);
                this.Fields.Add(typeGen);
            }
            await Task.WhenAll(this.gen.GenerationModules.Select((m) => m.PostFieldLoad(this, typeGen, fieldNode)));
            typeGen.FinalizeField();
        }

        public async Task Generate()
        {
            if (this.Disabled != DisabledLevel.Enabled) return;
            FileGeneration fg = new FileGeneration();
            fg.AppendLine("/*");
            fg.AppendLine(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");
            fg.AppendLine(" * Autogenerated by Loqui.  Do not manually change.");
            fg.AppendLine(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");
            fg.AppendLine("*/");

            AddNamespaces(fg);

            using (new NamespaceWrapper(fg, this.Namespace))
            {
                if (GenerateClass)
                {
                    await GenerateClassFile(fg);
                }

                await GenerateInterfaces(fg);
            }
            fg.AppendLine();

            using (new NamespaceWrapper(fg, this.InternalNamespace))
            {
                GenerateEnumIndex(fg);
                await GenerateRegistration(fg);
                await GenerateInterfaceExtensions(fg);
                await GenerateTranslations(fg);
                GenerateLoquiInterfaces(fg);
            }

            var fileName = Path.Combine(TargetDir.FullName, FileName);
            var file = new FileInfo(fileName);
            this.GeneratedFiles[Path.GetFullPath(fileName)] = ProjItemType.Compile;
            fg.Generate(file);
            if (!this.gen.GeneratedFiles.Add(fileName))
            {
                throw new ArgumentException();
            }
        }

        public bool HasKeyField()
        {
            foreach (var field in this.IterateFields())
            {
                if (field.KeyField) return true;
            }
            if (this.HasBaseObject)
            {
                return this.BaseClass.HasKeyField();
            }
            return false;
        }

        public static string GenerateGenericClause(IEnumerable<string> keys)
        {
            if (!keys.Any()) return string.Empty;
            return $"<{string.Join(", ", keys)}>";
        }

        public void WriteWhereClauses(FileGeneration fg, IEnumerable<KeyValuePair<string, GenericDefinition>> defs)
        {
            using (new DepthWrapper(fg))
            {
                foreach (var item in GenerateWhereClauses(defs))
                {
                    fg.AppendLine(item);
                }
            }
        }

        public IEnumerable<string> GenerateWhereClauses(IEnumerable<KeyValuePair<string, GenericDefinition>> defs = null)
        {
            foreach (var gen in (defs ?? this.Generics))
            {
                List<string> wheres = new List<string>();
                if (gen.Value.MustBeClass)
                {
                    wheres.Add("class");
                }
                wheres.AddRange(gen.Value.Wheres);
                if (wheres.Count > 0)
                {
                    yield return $"where {gen.Key} : {string.Join(", ", wheres)}";
                }
            }
        }

        public void GenerateForField(FileGeneration fg, TypeGeneration field)
        {
            if (!field.GenerateClassMembers) return;
            using (new RegionWrapper(fg, field.Name) { AppendExtraLine = false })
            {
                field.GenerateForClass(fg);
            }
        }

        private async Task GenerateClassFile(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Class"))
            {
                GenerateClassLine(fg);

                WriteWhereClauses(fg, this.Generics);

                using (new BraceWrapper(fg))
                {
                    GenerateRegistrationRouting(fg);

                    GenerateRaisePropertyChanged(fg);

                    await GenerateCtor(fg);

                    await GenerateStaticCtor(fg);
                    // Generate fields
                    foreach (var field in this.IterateFieldIndices())
                    {
                        GenerateForField(fg, field.Field);
                    }
                    fg.AppendLine();

                    GenerateLoquiGetterInterface(fg);

                    GenerateLoquiSetterInterface(fg);

                    GenerateToStringCode(fg);

                    GenerateGetHasBeenSetMask(fg);

                    GenerateEqualsSection(fg);

                    await GenerateModules(fg);

                    GenerateInterfacesInClass(fg);

                    GenerateCopy(fg);

                    GenerateSetNthObject(fg);

                    GenerateClear(fg, true);

                    GenerateGenericCreate(fg);
                }
            }
        }

        private async Task GenerateInterfaces(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Interface"))
            {
                await GenerateSetterInterface(fg);
                await GenerateGetterInterface(fg);
            }
        }

        protected virtual async Task GenerateSetterInterface(FileGeneration fg)
        {
            // Interface
            fg.AppendLine($"public interface {this.InterfaceStr} : {this.Getter_InterfaceStr}{(this.HasBaseObject ? ", " + this.BaseClass.InterfaceStr_Generic(this.BaseGenericTypes) : string.Empty)}, ILoquiClass<{this.InterfaceStr}, {this.Getter_InterfaceStr}>, ILoquiClass<{this.ObjectName}, {this.Getter_InterfaceStr}>");
            WriteWhereClauses(fg, this.Generics);
            using (new BraceWrapper(fg))
            {
                foreach (var field in this.IterateFields())
                {
                    field.GenerateForInterface(fg);
                }
            }
            fg.AppendLine();
        }

        protected virtual async Task GenerateGetterInterface(FileGeneration fg)
        {
            // Getter 
            fg.AppendLine($"public interface {this.Getter_InterfaceStr} : {(this.HasBaseObject ? this.BaseClass.Getter_InterfaceStr_Generic(this.BaseGenericTypes) : nameof(ILoquiObject))}");
            WriteWhereClauses(fg, this.Generics);

            using (new BraceWrapper(fg))
            {
                foreach (var field in this.IterateFields())
                {
                    using (new RegionWrapper(fg, field.Name) { AppendExtraLine = false })
                    {
                        field.GenerateForGetterInterface(fg);
                    }
                }
                fg.AppendLine();

                foreach (var mod in this.gen.GenerationModules)
                {
                    using (new RegionWrapper(fg, mod.RegionString))
                    {
                        await mod.GenerateInInterfaceGetter(this, fg);
                    }
                }
            }
            fg.AppendLine();
        }

        protected void GenerateEnumIndex(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Field Index"))
            {
                fg.AppendLine($"public enum {this.FieldIndexName}");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFieldIndices(includeBaseClass: true))
                    {
                        if (!field.Field.IntegrateField) continue;
                        fg.AppendLine($"{field.Field.Name} = {field.PublicIndex},");
                    }
                }
            }
        }

        protected async Task GenerateRegistration(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Registration"))
            {
                fg.AppendLine($"public class {this.RegistrationName} : ILoquiRegistration");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"public static readonly {this.RegistrationName} Instance = new {this.RegistrationName}();");
                    fg.AppendLine();

                    fg.AppendLine($"public static ProtocolKey ProtocolKey => {this.ProtocolDefinitionName}.ProtocolKey;");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly ObjectKey ObjectKey = new ObjectKey(");
                    using (new DepthWrapper(fg))
                    {
                        fg.AppendLine($"protocolKey: {this.ProtocolDefinitionName}.ProtocolKey,");
                        fg.AppendLine($"msgID: {this.ID},");
                        fg.AppendLine($"version: {this.Version});");
                    }
                    fg.AppendLine();

                    fg.AppendLine($"public const string GUID = \"{this.GUID}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const ushort FieldCount = {this.IterateFields().Count()};");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type MaskType = typeof({this.GetMaskString("")});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type ErrorMaskType = typeof({this.Mask_Unspecified(MaskType.Error)});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type ClassType = typeof({this.Name}{this.EmptyGenerics});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type GetterType = typeof({this.Getter_InterfaceStr_NoGenerics}{this.EmptyGenerics});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type SetterType = typeof({this.Setter_InterfaceStr_NoGenerics}{this.EmptyGenerics});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type CommonType = typeof({this.ExtCommonName});");
                    fg.AppendLine();

                    fg.AppendLine($"public const string FullName = \"{this.FullName}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const string Name = \"{this.Name}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const string Namespace = \"{this.Namespace}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const byte GenericCount = {this.Generics.Count};");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type GenericRegistrationType = {(this.Generics.Count > 0 ? $"typeof({this.RegistrationName}{this.EmptyGenerics})" : "null")};");
                    fg.AppendLine();

                    GenerateGetNameIndex(fg);

                    GenerateNthObjectIsEnumerable(fg);

                    GenerateNthObjectIsLoqui(fg);

                    GenerateGetNthIsSingleton(fg);

                    GenerateGetNthName(fg);

                    GenerateNthObjectIsDerivative(fg);

                    GenerateIsProtected(fg);

                    if (this.Generics.Count == 0)
                    {
                        GenerateGetNthType(fg, false);
                    }
                    else
                    {
                        fg.AppendLine("public static Type GetNthType(ushort index) => throw new ArgumentException(\"Cannot get nth type for a generic object here.  Use generic registration instead.\");");
                        fg.AppendLine();
                    }

                    foreach (var mod in this.gen.GenerationModules)
                    {
                        await mod.GenerateInRegistration(this, fg);
                    }

                    using (new RegionWrapper(fg, "Interface"))
                    {
                        fg.AppendLine($"ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;");
                        fg.AppendLine($"ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;");
                        fg.AppendLine($"string ILoquiRegistration.GUID => GUID;");
                        fg.AppendLine($"int ILoquiRegistration.FieldCount => FieldCount;");
                        fg.AppendLine($"Type ILoquiRegistration.MaskType => MaskType;");
                        fg.AppendLine($"Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;");
                        fg.AppendLine($"Type ILoquiRegistration.ClassType => ClassType;");
                        fg.AppendLine($"Type ILoquiRegistration.SetterType => SetterType;");
                        fg.AppendLine($"Type ILoquiRegistration.GetterType => GetterType;");
                        fg.AppendLine($"Type ILoquiRegistration.CommonType => CommonType;");
                        fg.AppendLine($"string ILoquiRegistration.FullName => FullName;");
                        fg.AppendLine($"string ILoquiRegistration.Name => Name;");
                        fg.AppendLine($"string ILoquiRegistration.Namespace => Namespace;");
                        fg.AppendLine($"byte ILoquiRegistration.GenericCount => GenericCount;");
                        fg.AppendLine($"Type ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;");
                        fg.AppendLine($"ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => GetNameIndex(name);");
                        fg.AppendLine($"bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => GetNthIsEnumerable(index);");
                        fg.AppendLine($"bool ILoquiRegistration.GetNthIsLoqui(ushort index) => GetNthIsLoqui(index);");
                        fg.AppendLine($"bool ILoquiRegistration.GetNthIsSingleton(ushort index) => GetNthIsSingleton(index);");
                        fg.AppendLine($"string ILoquiRegistration.GetNthName(ushort index) => GetNthName(index);");
                        fg.AppendLine($"bool ILoquiRegistration.IsNthDerivative(ushort index) => IsNthDerivative(index);");
                        fg.AppendLine($"bool ILoquiRegistration.IsProtected(ushort index) => IsProtected(index);");
                        fg.AppendLine($"Type ILoquiRegistration.GetNthType(ushort index) => GetNthType(index);");

                    }
                }

                if (this.Generics.Count > 0)
                {
                    fg.AppendLine();
                    fg.AppendLine($"public class {this.RegistrationName}{this.GenericTypes} : {this.RegistrationName}");
                    WriteWhereClauses(fg, this.Generics);
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"public static readonly {this.RegistrationName}{this.GenericTypes} GenericInstance = new {this.RegistrationName}{this.GenericTypes}();");
                        fg.AppendLine();

                        GenerateGetNthType(fg, true);
                    }
                }
            }
        }

        private async Task GenerateInterfaceExtensions(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Extensions"))
            {
                fg.AppendLine($"public static partial class {this.ExtCommonName}");

                using (new BraceWrapper(fg))
                {
                    GenerateCopyFieldsFrom(fg);

                    GenerateSetNthObjectHasBeenSet(fg);

                    GenerateUnsetNthObject(fg);

                    GenerateGetNthObjectHasBeenSet(fg);

                    GenerateGetNthObject(fg);

                    GenerateClear(fg, false);

                    GenerateGetEqualsMask(fg);

                    GenerateCommonToString(fg);

                    GenerateHasBeenSetCheck(fg);

                    GenerateHasBeenSetMaskGetter(fg);

                    GenerateFieldIndexConverters(fg, this);

                    // Fields might add some content
                    foreach (var field in this.IterateFields())
                    {
                        field.GenerateForInterfaceExt(fg);
                    }

                    // Modules might add some content
                    foreach (var mod in this.gen.GenerationModules)
                    {
                        using (new RegionWrapper(fg, mod.RegionString))
                        {
                            await mod.GenerateInCommonExt(this, fg);
                        }
                    }
                }
            }
        }

        private void GenerateCommonToString(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static string ToString{this.GenericTypes}",
                GenerateWhereClauses().ToArray()))
            {
                args.Add($"this {this.Getter_InterfaceStr} item");
                args.Add($"string name = null");
                args.Add($"{this.GetMaskString("bool")} printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var fg = new {nameof(FileGeneration)}();");
                fg.AppendLine($"item.ToString(fg, name, printMask);");
                fg.AppendLine("return fg.ToString();");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static void ToString{this.GenericTypes}",
                GenerateWhereClauses().ToArray()))
            {
                args.Add($"this {this.Getter_InterfaceStr} item");
                args.Add($"{nameof(FileGeneration)} fg");
                args.Add($"string name = null");
                args.Add($"{this.GetMaskString("bool")} printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("if (name == null)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"fg.AppendLine($\"{{nameof({this.ObjectName})}} =>\");");
                }
                fg.AppendLine("else");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"fg.AppendLine($\"{{name}} ({{nameof({this.ObjectName})}}) =>\");");
                }
                fg.AppendLine($"fg.AppendLine(\"[\");");
                fg.AppendLine($"using (new DepthWrapper(fg))");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"if ({gen.MaskModule.GetMaskModule(field.GetType()).GenerateBoolMaskCheck(field, "printMask")})");
                        }
                        using (new BraceWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateToString(fg, field.Name, $"item.{field.Name}", "fg");
                        }
                    }
                }
                fg.AppendLine($"fg.AppendLine(\"]\");");
            }
            fg.AppendLine();
        }

        private void GenerateHasBeenSetCheck(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static bool HasBeenSet{this.GenericTypes}",
                GenerateWhereClauses().ToArray()))
            {
                args.Add($"this {this.Getter_InterfaceStr} item");
                args.Add($"{this.GetMaskString("bool?")} checkMask");
            }
            using (new BraceWrapper(fg))
            {
                foreach (var field in this.IterateFieldIndices())
                {
                    if (field.Field.Bare) continue;
                    field.Field.GenerateForHasBeenSetCheck(fg, $"item.{field.Field.Property}", $"checkMask.{field.Field.Name}");
                }
                fg.AppendLine("return true;");
            }
            fg.AppendLine();
        }

        private void GenerateHasBeenSetMaskGetter(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static {this.GetMaskString("bool")} GetHasBeenSetMask{this.GenericTypes}",
                GenerateWhereClauses().ToArray()))
            {
                args.Add($"{this.Getter_InterfaceStr} item");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var ret = new {this.GetMaskString("bool")}();");
                foreach (var field in this.IterateFieldIndices())
                {
                    field.Field.GenerateForHasBeenSetMaskGetter(fg, $"item.{field.Field.PropertyOrName}", $"ret.{field.Field.Name}");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();
        }

        private void GenerateFieldIndexConverters(FileGeneration fg, ObjectGeneration obj)
        {
            if (!obj.HasBaseObject) return;
            var baseObj = obj.BaseClass;
            using (var args = new FunctionWrapper(fg,
                $"public static {this.FieldIndexName}? ConvertFieldIndex"))
            {
                args.Add($"{baseObj.FieldIndexName}? index");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("if (!index.HasValue) return null;");
                using (var args = new ArgsWrapper(fg,
                    "return ConvertFieldIndex"))
                {
                    args.Add("index: index.Value");
                }
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static {this.FieldIndexName} ConvertFieldIndex"))
            {
                args.Add($"{baseObj.FieldIndexName} index");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("switch (index)");
                using (new BraceWrapper(fg))
                {
                    foreach (var (PublicIndex, InternalIndex, Field) in baseObj.IterateFieldIndices(includeBaseClass: true))
                    {
                        fg.AppendLine($"case {baseObj.FieldIndexName}.{Field.Name}:");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"return ({this.FieldIndexName})((int)index);");
                        }
                    }

                    fg.AppendLine("default:");
                    using (new DepthWrapper(fg))
                    {
                        GenerateIndexOutOfRangeEx(fg, $"index.{nameof(EnumExt.ToStringFast_Enum_Only)}()");
                    }
                }
            }
            fg.AppendLine();
            GenerateFieldIndexConverters(fg, baseObj);
        }

        protected virtual void GenerateStaticCopy_ToLoqui(FileGeneration fg)
        {
            fg.AppendLine($"return {this.ObjectName}.Copy(item, def: null);");
        }

        protected virtual void GenerateCopyFieldsFrom(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Copy Fields From"))
            {
                using (var args = new FunctionWrapper(fg,
                    $"public static void CopyFieldsFrom{this.GenericTypes_CopyMask}",
                    GenerateWhereClauses().And(this.GenericTypes_CopyMaskWheres).ToArray()))
                {
                    args.Add($"this {this.InterfaceStr} item");
                    args.Add($"{this.Getter_InterfaceStr} rhs");
                    args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                    args.Add($"{this.Getter_InterfaceStr} def = null");
                    args.Add($"NotifyingFireParameters? cmds = null");
                }
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        $"{this.ExtCommonName}.CopyFieldsFrom{this.GenericTypes_AssumedErrMask_CopyMask}"))
                    {
                        args.Add("item: item");
                        args.Add("rhs: rhs");
                        args.Add("def: def");
                        args.Add("doMasks: false");
                        args.Add("errorMask: null");
                        args.Add("copyMask: copyMask");
                        args.Add("cmds: cmds");
                    }
                }
                fg.AppendLine();

                using (var args = new FunctionWrapper(fg,
                    $"public static void CopyFieldsFrom{this.GenericTypes_ErrMask_CopyMask}",
                    wheres: All_Wheres))
                {
                    args.Add($"this {this.InterfaceStr} item");
                    args.Add($"{this.Getter_InterfaceStr} rhs");
                    args.Add($"out {this.Mask(MaskType.Error)} errorMask");
                    args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                    args.Add($"{this.Getter_InterfaceStr} def = null");
                    args.Add($"NotifyingFireParameters? cmds = null");
                }
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        $"{this.ExtCommonName}.CopyFieldsFrom{this.GenericTypes_ErrMask_CopyMask}"))
                    {
                        args.Add("item: item");
                        args.Add("rhs: rhs");
                        args.Add("def: def");
                        args.Add("doMasks: true");
                        args.Add("errorMask: out errorMask");
                        args.Add("copyMask: copyMask");
                        args.Add("cmds: cmds");
                    }
                }
                fg.AppendLine();

                using (var args = new FunctionWrapper(fg,
                    $"public static void CopyFieldsFrom{this.GenericTypes_ErrMask_CopyMask}",
                    wheres: All_Wheres))
                {
                    args.Add($"this {this.InterfaceStr} item");
                    args.Add($"{this.Getter_InterfaceStr} rhs");
                    args.Add($"{this.Getter_InterfaceStr} def");
                    args.Add($"bool doMasks");
                    args.Add($"out {this.Mask(MaskType.Error)} errorMask");
                    args.Add($"{this.Mask(MaskType.Copy)} copyMask");
                    args.Add($"NotifyingFireParameters? cmds");
                }
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"{this.Mask(MaskType.Error)} retErrorMask = null;");
                    fg.AppendLine($"Func<{this.Mask(MaskType.Error)}> maskGetter = () =>");
                    using (new BraceWrapper(fg) { AppendSemicolon = true })
                    {
                        fg.AppendLine($"if (retErrorMask == null)");
                        using (new BraceWrapper(fg))
                        {
                            fg.AppendLine($"retErrorMask = new {this.Mask(MaskType.Error)}();");
                        }
                        fg.AppendLine("return retErrorMask;");
                    }
                    using (var args = new ArgsWrapper(fg,
                        $"CopyFieldsFrom{this.GenericTypes_ErrMask_CopyMask}"))
                    {
                        args.Add("item: item");
                        args.Add("rhs: rhs");
                        args.Add("def: def");
                        args.Add("doMasks: true");
                        args.Add("errorMask: maskGetter");
                        args.Add("copyMask: copyMask");
                        args.Add("cmds: cmds");
                    }
                    fg.AppendLine("errorMask = retErrorMask;");
                }
                fg.AppendLine();

                using (var args = new FunctionWrapper(fg,
                    $"public static void CopyFieldsFrom{this.GenericTypes_ErrMask_CopyMask}",
                    wheres: All_Wheres))
                {
                    args.Add($"this {this.InterfaceStr} item");
                    args.Add($"{this.Getter_InterfaceStr} rhs");
                    args.Add($"{this.Getter_InterfaceStr} def");
                    args.Add($"bool doMasks");
                    args.Add($"Func<{this.Mask(MaskType.Error)}> errorMask");
                    args.Add($"{this.Mask(MaskType.Copy)} copyMask");
                    args.Add($"NotifyingFireParameters? cmds");
                }
                using (new BraceWrapper(fg))
                {
                    GenerateCopyForFields(
                        fg,
                        "item",
                        "rhs",
                        defaultFallbackAccessor: "def",
                        doErrMaskAccessor: "doMasks",
                        errMaskAccessor: "errorMask",
                        copyMaskAccessor: "copyMask",
                        cmdsAccessor: "cmds");
                }
                fg.AppendLine();
            }
        }

        private void GenerateCopyForFields(
            FileGeneration fg,
            string accessorPrefix,
            string rhsAccessorPrefix,
            string defaultFallbackAccessor,
            string doErrMaskAccessor,
            string errMaskAccessor,
            string copyMaskAccessor,
            string cmdsAccessor)
        {
            if (this.HasBaseObject)
            {
                using (var args = new ArgsWrapper(fg,
                    $"{this.BaseClass.ExtCommonName}.CopyFieldsFrom{this.BaseGenericTypes_ErrMask_CopyMask}"))
                {
                    args.Add(accessorPrefix);
                    args.Add(rhsAccessorPrefix);
                    args.Add(defaultFallbackAccessor);
                    args.Add(doErrMaskAccessor);
                    args.Add(errMaskAccessor);
                    args.Add(copyMaskAccessor);
                    args.Add(cmdsAccessor);
                }
            }

            foreach (var item in this.IterateFieldIndices())
            {
                if (!item.Field.Copy || !item.Field.IntegrateField) continue;
                fg.AppendLine($"if ({item.Field.SkipCheck(copyMaskAccessor)})");
                using (new BraceWrapper(fg))
                {
                    if (item.Field.CopyNeedsTryCatch)
                    {
                        fg.AppendLine("try");
                        using (new BraceWrapper(fg))
                        {
                            item.Field.GenerateForCopy(
                                fg,
                                accessorPrefix,
                                rhsAccessorPrefix,
                                $"{copyMaskAccessor}?.{item.Field.Name}",
                                defaultFallbackAccessor,
                                cmdsAccessor: cmdsAccessor,
                                protectedMembers: false);
                        }
                        GenerateExceptionCatcher(fg, item.Field, doErrMaskAccessor, errMaskAccessor, $"{item.Field.IndexEnumName}");
                    }
                    else
                    {
                        item.Field.GenerateForCopy(
                            fg,
                            accessorPrefix,
                            rhsAccessorPrefix,
                            $"{copyMaskAccessor}.{item.Field.Name}",
                            defaultFallbackAccessor,
                            cmdsAccessor: cmdsAccessor,
                            protectedMembers: false);
                    }
                }
            }
        }

        #region Generation Snippets
        protected void GenerateRegistrationRouting(FileGeneration fg)
        {
            fg.AppendLine($"ILoquiRegistration ILoquiObject.Registration => {this.RegistrationName}.Instance;");
            fg.AppendLine($"public{NewOverride}static {this.RegistrationName} Registration => {this.RegistrationName}.Instance;");
            fg.AppendLine();
        }

        protected void GenerateRaisePropertyChanged(FileGeneration fg)
        {
            if (!this.HasRaisedPropertyChanged) return;
            using (new RegionWrapper(fg, "PropertyChangedHandler"))
            {
                fg.AppendLine($"public event PropertyChangedEventHandler PropertyChanged;");
                fg.AppendLine();

                fg.AppendLine($"protected void OnPropertyChanged(string name)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));");
                }
            }
        }

        protected abstract Task GenerateCtor(FileGeneration fg);

        protected async Task GenerateStaticCtor(FileGeneration fg)
        {
            FileGeneration staticCtorFG = new FileGeneration();
            foreach (var mod in this.gen.GenerationModules)
            {
                await mod.GenerateInStaticCtor(this, staticCtorFG);
            }
            foreach (var field in this.IterateFields())
            {
                field.GenerateForStaticCtor(staticCtorFG);
            }
            if (staticCtorFG.Strings.Count == 0) return;
            fg.AppendLine($"static {this.Name}()");
            using (new BraceWrapper(fg))
            {
                fg.AppendLines(staticCtorFG.Strings);
            }
            fg.AppendLine();
        }

        protected abstract void GenerateClassLine(FileGeneration fg);

        public void GenerateLoquiGetterInterface(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Loqui Getter Interface"))
            {
                fg.AppendLine();

                fg.AppendLine($"protected{this.FunctionOverride()}object GetNthObject(ushort index) => {this.ExtCommonName}.GetNthObject{this.GenericTypes}(index, this);");
                if (this.IsTopClass)
                {
                    fg.AppendLine($"object ILoquiObjectGetter.GetNthObject(ushort index) => this.GetNthObject(index);");
                }
                fg.AppendLine();

                using (new LineWrapper(fg))
                {
                    fg.Append($"protected{this.FunctionOverride()}bool GetNthObjectHasBeenSet(ushort index) => ");
                    if (this is ClassGeneration)
                    {
                        fg.Append($"{this.ExtCommonName}.GetNthObjectHasBeenSet{this.GenericTypes}(index, this);");
                    }
                    else
                    {
                        fg.Append("true;");
                    }
                }
                if (this.IsTopClass)
                {
                    fg.AppendLine($"bool ILoquiObjectGetter.GetNthObjectHasBeenSet(ushort index) => this.GetNthObjectHasBeenSet(index);");
                }
                fg.AppendLine();

                fg.AppendLine($"protected{this.FunctionOverride()}void UnsetNthObject(ushort index, NotifyingUnsetParameters? cmds) => {this.ExtCommonName}.UnsetNthObject{this.GenericTypes}(index, this, cmds);");
                if (this.IsTopClass)
                {
                    fg.AppendLine($"void ILoquiObjectSetter.UnsetNthObject(ushort index, NotifyingUnsetParameters? cmds) => this.UnsetNthObject(index, cmds);");
                }
                fg.AppendLine();
            }
        }

        protected virtual void GenerateLoquiSetterInterface(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Loqui Interface"))
            {
                fg.AppendLine($"protected{this.FunctionOverride()}void SetNthObjectHasBeenSet(ushort index, bool on)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"{this.ExtCommonName}.SetNthObjectHasBeenSet{this.GenericTypes}(index, on, this);");
                }
                if (this.IsTopClass)
                {
                    fg.AppendLine($"void ILoquiObjectSetter.SetNthObjectHasBeenSet(ushort index, bool on) => this.SetNthObjectHasBeenSet(index, on);");
                }
                fg.AppendLine();
            }
        }

        private void GenerateProtocolProperty(FileGeneration fg)
        {
            fg.AppendLine($"public static ProtocolKey Loqui_ProtocolKey_Static => new ProtocolKey({ProtoGen.Protocol.Namespace});");

            fg.AppendLine($"public{this.FunctionOverride()}ProtocolKey Loqui_ProtocolKey => Loqui_ProtocolKey_Static;");

            fg.AppendLine($"public static ObjectKey Loqui_ObjectKey_Static => new ObjectKey(protocolKey: Loqui_ProtocolKey_Static, msgID: {this.ID}, version: {this.Version});");

            fg.AppendLine($"public{this.FunctionOverride()}ObjectKey Loqui_ObjectKey => Loqui_ObjectKey_Static;");
        }

        private void GenerateGetNthObject(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static object GetNthObject{this.GenericTypes}",
                GenerateWhereClauses().ToArray()))
            {
                args.Add($"ushort index");
                args.Add($"{this.Getter_InterfaceStr} obj");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNth(fg, "obj");
                        }
                    }

                    GenerateStandardIndexDefault(fg, "GetNthObject", "index", true, true, "obj");
                }
            }
            fg.AppendLine();
        }

        protected virtual void GenerateGetNthObjectHasBeenSet(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static bool GetNthObjectHasBeenSet{this.GenericTypes}",
                GenerateWhereClauses().ToArray()))
            {
                args.Add($"ushort index");
                args.Add($"{this.InterfaceStr} obj");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var nonNotifying = IterateFieldIndices()
                        .Where((f) => !f.Field.HasBeenSet).ToList();
                    if (nonNotifying.Count > 0)
                    {
                        foreach (var item in nonNotifying)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"return true;");
                        }
                    }

                    foreach (var field in this.IterateFields().Where((field) => field.HasBeenSet))
                    {
                        if (field.IntegrateField)
                        {
                            if (field.Bare) continue;
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNthObjectHasBeenSet(fg);
                        }
                    }

                    GenerateStandardIndexDefault(fg, "GetNthObjectHasBeenSet", "index", true, true, "obj");
                }
            }
            fg.AppendLine();
        }

        protected virtual void GenerateSetNthObject(FileGeneration fg)
        {
            if (this.IsTopClass)
            {
                fg.AppendLine("void ILoquiObjectSetter.SetNthObject(ushort index, object obj, NotifyingFireParameters? cmds) => this.SetNthObject(index, obj, cmds);");
            }
            fg.AppendLine($"protected{this.FunctionOverride()}void SetNthObject(ushort index, object obj, NotifyingFireParameters? cmds = null)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var derivatives = IterateFieldIndices()
                        .Where((f) => f.Field.Derivative).ToList();
                    if (derivatives.Count > 0)
                    {
                        foreach (var item in derivatives)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("throw new ArgumentException($\"Tried to set at a derivative index {index}\");");
                        }
                    }
                    foreach (var field in this.IterateFields())
                    {
                        if (field.Derivative) continue;
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateSetNth(
                                fg,
                                accessorPrefix: $"this",
                                rhsAccessorPrefix: $"({field.SetToName})obj",
                                cmdsAccessor: "cmds",
                                internalUse: false);
                        }
                    }

                    GenerateStandardIndexDefault(fg, "SetNthObject", "index", false, false, "obj", "cmds");
                }
            }
            fg.AppendLine();
        }

        protected virtual void GenerateSetNthObjectHasBeenSet(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static void SetNthObjectHasBeenSet{this.GenericTypes}",
                GenerateWhereClauses().ToArray()))
            {
                args.Add($"ushort index");
                args.Add($"bool on");
                args.Add($"{this.InterfaceStr} obj");
                args.Add($"{nameof(NotifyingFireParameters)}? cmds = null");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    HashSet<int> coveredFields = new HashSet<int>();

                    // Non integrated fields
                    foreach (var field in this.IterateFieldIndices())
                    {
                        if (field.Field.IntegrateField) continue;
                        coveredFields.Add(field.PublicIndex);
                    }

                    // Derivative fields
                    var derivatives = IterateFieldIndices()
                        .Where((f) => f.Field.Derivative && coveredFields.Add(f.PublicIndex)).ToList();
                    if (derivatives.Count > 0)
                    {
                        foreach (var item in derivatives)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("throw new ArgumentException($\"Tried to set at a derivative index {index}\");");
                        }
                    }

                    // Non Has Been Set
                    var nonHasBeenSetFields = IterateFieldIndices().
                        Where((f) =>
                            !f.Field.HasBeenSet
                            && coveredFields.Add(f.PublicIndex))
                        .ToList();
                    if (nonHasBeenSetFields.Count > 0)
                    {
                        foreach (var field in nonHasBeenSetFields.Select((f) => f.Field))
                        {
                            if (field.Derivative) continue;
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("if (on) break;");
                            fg.AppendLine("throw new ArgumentException(\"Tried to unset a field which does not have this functionality.\" + index);");
                        }
                    }

                    // Protected
                    var protectedFields = IterateFieldIndices().
                        Where((f) =>
                            f.Field.ReadOnly
                            && coveredFields.Add(f.PublicIndex))
                        .ToList();
                    if (protectedFields.Count > 0)
                    {
                        foreach (var field in protectedFields.Select((f) => f.Field))
                        {
                            if (field.Derivative) continue;
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("throw new ArgumentException(\"Tried to set at a readonly index \" + index);");
                        }
                    }

                    // Normal
                    foreach (var field in this.IterateFieldIndices().Where((f) => coveredFields.Add(f.PublicIndex)).Select((f) => f.Field))
                    {
                        fg.AppendLine($"case {field.IndexEnumName}:");
                        using (new DepthWrapper(fg))
                        {
                            field.GenerateSetNthHasBeenSet(fg, "obj", "on");
                        }
                    }

                    GenerateStandardIndexDefault(fg, "SetNthObjectHasBeenSet", "index", false, true, "on", "obj");
                }
            }
            fg.AppendLine();
        }

        protected virtual void GenerateUnsetNthObject(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static void UnsetNthObject{this.GenericTypes}",
                this.GenerateWhereClauses().ToArray()))
            {
                args.Add("ushort index");
                args.Add($"{this.InterfaceStr} obj");
                args.Add($"{nameof(NotifyingUnsetParameters)}? cmds = null");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var derivatives = IterateFieldIndices()
                        .Where((f) => f.Field.Derivative).ToList();
                    if (derivatives.Count > 0)
                    {
                        foreach (var item in derivatives)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("throw new ArgumentException($\"Tried to unset at a derivative index {index}\");");
                        }
                    }
                    foreach (var field in this.IterateFields())
                    {
                        if (field.Derivative) continue;

                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            if (field.IntegrateField && field.ReadOnly)
                            {
                                fg.AppendLine("throw new ArgumentException(\"Tried to set at a readonly index \" + index);");
                            }
                            else
                            {
                                field.GenerateUnsetNth(fg, "obj", "cmds");
                            }
                        }
                    }

                    GenerateStandardIndexDefault(fg, "UnsetNthObject", "index", false, true, "obj");
                }
            }
            fg.AppendLine();
        }

        private void GenerateNthObjectIsLoqui(FileGeneration fg)
        {
            fg.AppendLine("public static bool GetNthIsLoqui(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    Func<TypeGeneration, bool> tester = (t) =>
                    {
                        if (t is LoquiType)
                        {
                            return true;
                        }
                        else if (t is ContainerType)
                        {
                            ContainerType listField = t as ContainerType;
                            if (listField.SubTypeGeneration is LoquiType)
                            {
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                        else
                        {
                            return false;
                        }
                    };

                    var trues = IterateFieldIndices().Where((i) => tester(i.Field));
                    var falses = IterateFieldIndices().Where((i) => !tester(i.Field));
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthIsLoqui", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateNthObjectIsDerivative(FileGeneration fg)
        {
            fg.AppendLine("public static bool IsNthDerivative(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var trues = IterateFieldIndices().Where((i) => i.Field.Derivative);
                    var falses = IterateFieldIndices().Where((i) => !i.Field.Derivative);
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "IsNthDerivative", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateNthObjectIsEnumerable(FileGeneration fg)
        {
            fg.AppendLine("public static bool GetNthIsEnumerable(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var trues = IterateFieldIndices().Where((i) => i.Field is ContainerType);
                    var falses = IterateFieldIndices().Where((i) => !(i.Field is ContainerType));
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthIsEnumerable", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetNthType(FileGeneration fg, bool generic)
        {
            fg.AppendLine($"public{(generic ? " new " : " ")}static Type GetNthType(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNthType(fg);
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthType", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetNthName(FileGeneration fg)
        {
            fg.AppendLine("public static string GetNthName(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNthName(fg);
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthName", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetNthIsSingleton(FileGeneration fg)
        {
            fg.AppendLine("public static bool GetNthIsSingleton(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    Func<TypeGeneration, bool> tester = (f) =>
                    {
                        if (!(f is LoquiType loqui)) return false;
                        return loqui.SingletonType == SingletonLevel.Singleton;
                    };
                    var trues = IterateFieldIndices().Where((i) => tester(i.Field));
                    var falses = IterateFieldIndices().Where((i) => !tester(i.Field));
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthIsSingleton", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetEqualsMask(FileGeneration fg)
        {

            using (var args = new FunctionWrapper(fg, $"public static {this.GetMaskString("bool")} GetEqualsMask{this.GenericTypes}",
                GenerateWhereClauses().ToArray()))
            {
                args.Add($"this {this.Getter_InterfaceStr} item");
                args.Add($"{this.Getter_InterfaceStr} rhs");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var ret = new {this.GetMaskString("bool")}();");
                fg.AppendLine($"FillEqualsMask(item, rhs, ret);");
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg, $"public static void FillEqualsMask{this.GenericTypes}",
                GenerateWhereClauses().ToArray()))
            {
                args.Add($"{this.Getter_InterfaceStr} item");
                args.Add($"{this.Getter_InterfaceStr} rhs");
                args.Add($"{this.GetMaskString("bool")} ret");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("if (rhs == null) return;");
                foreach (var field in this.IterateFields())
                {
                    if (!HasKeyField() || field.KeyField)
                    {
                        field.GenerateForEqualsMask(
                            fg,
                            new Accessor(field, $"item."),
                            new Accessor(field, "rhs."),
                            $"ret.{field.Name}");
                    }
                }
                if (this.HasBaseObject)
                {
                    fg.AppendLine($"{this.BaseClass.ExtCommonName}.FillEqualsMask(item, rhs, ret);");
                }
            }
            fg.AppendLine();
        }

        public void GenerateStandardRegistrationDefault(FileGeneration fg, string functionName, string indexAccessor, bool ret, params string[] otherParameters)
        {
            fg.AppendLine("default:");
            using (new DepthWrapper(fg))
            {
                if (this.HasBaseObject)
                {
                    fg.AppendLine($"{(ret ? "return " : string.Empty)}{BaseClass.RegistrationName}.{functionName}({string.Join(", ", indexAccessor.And(otherParameters))});");
                    if (!ret)
                    {
                        fg.AppendLine("break;");
                    }
                }
                else
                {
                    GenerateIndexOutOfRangeEx(fg, indexAccessor);
                }
            }
        }

        public void GenerateStandardIndexDefault(
            FileGeneration fg,
            string functionName,
            string indexAccessor,
            bool ret,
            bool common,
            params string[] otherParameters)
        {
            fg.AppendLine("default:");
            using (new DepthWrapper(fg))
            {
                if (this.HasBaseObject)
                {
                    if (common)
                    {
                        fg.AppendLine($"{(ret ? "return " : string.Empty)}{BaseClass.ExtCommonName}.{functionName}{this.BaseGenericTypes}({string.Join(", ", indexAccessor.And(otherParameters))});");
                    }
                    else
                    {
                        fg.AppendLine($"{(ret ? "return " : string.Empty)}base.{functionName}({string.Join(", ", indexAccessor.And(otherParameters))});");
                    }
                    if (!ret)
                    {
                        fg.AppendLine("break;");
                    }
                }
                else
                {
                    GenerateIndexOutOfRangeEx(fg, indexAccessor);
                }
            }
        }

        public void GenerateIndexOutOfRangeEx(FileGeneration fg, string indexAccessor)
        {
            fg.AppendLine($"throw new ArgumentException($\"Index is out of range: {{{indexAccessor}}}\");");
        }

        private void GenerateGetNameIndex(FileGeneration fg)
        {
            fg.AppendLine("public static ushort? GetNameIndex(StringCaseAgnostic str)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("switch (str.Upper)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField)
                        {
                            if (string.IsNullOrWhiteSpace(field.Name)) return;
                            fg.AppendLine($"case \"{field.Name.ToUpper()}\":");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNameIndex(fg);
                        }
                    }

                    fg.AppendLine("default:");
                    using (new DepthWrapper(fg))
                    {
                        fg.AppendLine("return null;");
                    }
                }
            }
            fg.AppendLine();
        }

        private void AddNamespaces(FileGeneration fg)
        {
            RequiredNamespaces.Add(
                this.gen.GenerationModules.SelectMany((tr) => tr.RequiredUsingStatements(this))
                .Union(this.GenerationInterfaces.SelectMany((i) => i.RequiredUsingStatements())));
            foreach (var nameSpace in RequiredNamespaces.Union(gen.Namespaces))
            {
                fg.AppendLine($"using {nameSpace};");
            }
            fg.AppendLine();
        }

        protected abstract void GenerateEqualsCode(FileGeneration fg);

        private void GenerateEqualsSection(FileGeneration fg)
        {
            // Generate equals and hash
            if (GenerateEquals)
            {
                using (new RegionWrapper(fg, "Equals and Hash"))
                {
                    fg.AppendLine("public override bool Equals(object obj)");
                    using (new BraceWrapper(fg))
                    {
                        GenerateEqualsCode(fg);
                    }
                    fg.AppendLine();

                    fg.AppendLine($"public bool Equals({this.ObjectName} rhs)");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine("if (rhs == null) return false;");
                        if (this.HasBaseObject)
                        {
                            fg.AppendLine($"if (!base.Equals(rhs)) return false;");
                        }
                        foreach (var field in this.IterateFields())
                        {
                            if (!HasKeyField() || field.KeyField)
                            {
                                if (field.Bare)
                                {
                                    field.GenerateForEquals(fg, "rhs");
                                }
                                else if (field.IntegrateField)
                                {
                                    if (field.HasBeenSet)
                                    {
                                        fg.AppendLine($"if ({field.HasBeenSetAccessor} != rhs.{field.HasBeenSetAccessor}) return false;");
                                        fg.AppendLine($"if ({field.HasBeenSetAccessor})");
                                        using (new BraceWrapper(fg))
                                        {
                                            field.GenerateForEquals(fg, "rhs");
                                        }
                                    }
                                    else
                                    {
                                        field.GenerateForEquals(fg, "rhs");
                                    }
                                }
                                else
                                {
                                    field.GenerateForEquals(fg, "rhs");
                                }
                            }
                        }
                        fg.AppendLine("return true;");
                    }
                    fg.AppendLine();

                    fg.AppendLine("public override int GetHashCode()");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine("int ret = 0;");
                        foreach (var field in this.IterateFields())
                        {
                            if (!HasKeyField() || field.KeyField)
                            {
                                if (field.Bare)
                                {
                                    field.GenerateForHash(fg, "ret");
                                }
                                else if (field.IntegrateField)
                                {
                                    if (field.HasBeenSet)
                                    {
                                        fg.AppendLine($"if ({field.HasBeenSetAccessor})");
                                    }
                                    using (new BraceWrapper(fg, doIt: field.HasBeenSet))
                                    {
                                        field.GenerateForHash(fg, "ret");
                                    }
                                }
                                else
                                {
                                    field.GenerateForHash(fg, "ret");
                                }
                            }
                        }
                        if (this.HasBaseObject)
                        {
                            fg.AppendLine($"ret = ret.CombineHashCode(base.GetHashCode());");
                        }
                        fg.AppendLine("return ret;");
                    }
                    fg.AppendLine();
                }
                fg.AppendLine();
            }
        }

        private void GenerateToStringCode(FileGeneration fg)
        {
            if (GenerateToString)
            {
                using (new RegionWrapper(fg, "To String"))
                {
                    fg.AppendLine($"public override string ToString()");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"return {this.ExtCommonName}.ToString(this, printMask: null);");
                    }
                    fg.AppendLine();

                    using (var args = new FunctionWrapper(fg,
                        $"public string ToString"))
                    {
                        args.Add($"string name = null");
                        args.Add($"{this.GetMaskString("bool")} printMask = null");
                    }
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"return {this.ExtCommonName}.ToString(this, name: name, printMask: printMask);");
                    }
                    fg.AppendLine();

                    using (var args = new FunctionWrapper(fg,
                        $"public{this.FunctionOverride()}void ToString"))
                    {
                        args.Add($"FileGeneration fg");
                        args.Add($"string name = null");
                    }
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"{this.ExtCommonName}.ToString(this, fg, name: name, printMask: null);");
                    }
                    fg.AppendLine();
                }
            }
        }

        private void GenerateGetHasBeenSetMask(FileGeneration fg)
        {
            fg.AppendLine($"public{this.NewOverride}{this.GetMaskString("bool")} GetHasBeenSetMask()");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"return {this.ExtCommonName}.GetHasBeenSetMask(this);");
            }
        }

        private async Task GenerateModules(FileGeneration fg)
        {
            if (this.gen.GenerationModules.Count > 0)
            {
                foreach (var transl in gen.GenerationModules)
                {
                    using (new RegionWrapper(fg, transl.RegionString))
                    {
                        await transl.GenerateInClass(this, fg);
                    }
                }
            }
        }

        private void GenerateInterfacesInClass(FileGeneration fg)
        {
            if (this.GenerationInterfaces.Count > 0)
            {
                foreach (var interf in gen.GenerationInterfaces)
                {
                    using (new RegionWrapper(fg, interf.RegionString))
                    {
                        interf.GenerateInClass(this, fg);
                    }
                }
            }
        }

        protected virtual void GenerateCopy_ToObject(FileGeneration fg)
        {
            fg.AppendLine($"{this.ProtectedKeyword}{this.FunctionOverride()}object Copy_ToObject(object def = null)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var ret = new {this.ObjectName}();");
                fg.AppendLine($"ret.CopyFieldsFrom_Generic(this, def: def, cmds: null);");
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();
        }

        public virtual void GenerateCopy(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public {this.ObjectName} Copy{this.Mask_GenericClause(MaskType.Copy)}",
                wheres: this.GenericTypes_CopyMaskWheres))
            {
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                args.Add($"{this.Getter_InterfaceStr} def = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return {this.ObjectName}.Copy"))
                {
                    args.Add("this");
                    args.Add("copyMask: copyMask");
                    args.Add("def: def");
                }
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static {this.ObjectName} Copy{this.Mask_GenericClause(MaskType.Copy)}",
                wheres: this.GenericTypes_CopyMaskWheres))
            {
                args.Add($"{this.InterfaceStr} item");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                args.Add($"{this.Getter_InterfaceStr} def = null");
            }
            using (new BraceWrapper(fg))
            {
                if (this.Abstract)
                {
                    fg.AppendLine($"{this.ObjectName} ret = ({this.ObjectName})System.Activator.CreateInstance(item.GetType());");
                }
                else
                {
                    fg.AppendLine($"{this.ObjectName} ret;");
                    fg.AppendLine($"if (item.GetType().Equals(typeof({this.ObjectName})))");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"ret = new {this.ObjectName}();");
                    }
                    fg.AppendLine("else");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"ret = ({this.ObjectName})System.Activator.CreateInstance(item.GetType());");
                    }
                }
                using (var args = new ArgsWrapper(fg,
                    "ret.CopyFieldsFrom"))
                {
                    args.Add("item");
                    args.Add("copyMask: copyMask");
                    args.Add("def: def");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static CopyType CopyGeneric{GenerateGenericClause("CopyType".And(GenericTypes_Nickname(MaskType.Copy)))}",
                wheres: this.GenericTypes_CopyMaskWheres))
            {
                args.Add($"CopyType item");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                args.Add($"{this.Getter_InterfaceStr} def = null");
            }
            using (new DepthWrapper(fg))
            {
                fg.AppendLine($"where CopyType : class, {this.InterfaceStr}");
            }
            using (new BraceWrapper(fg))
            {
                if (this.Abstract)
                {
                    fg.AppendLine($"CopyType ret = (CopyType)System.Activator.CreateInstance(item.GetType());");
                }
                else
                {
                    fg.AppendLine($"CopyType ret;");
                    fg.AppendLine($"if (item.GetType().Equals(typeof({this.ObjectName})))");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"ret = new {this.ObjectName}() as CopyType;");
                    }
                    fg.AppendLine("else");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"ret = (CopyType)System.Activator.CreateInstance(item.GetType());");
                    }
                }
                using (var args = new ArgsWrapper(fg,
                    $"ret.CopyFieldsFrom{this.GenericTypes_AssumedErrMask_CopyMask}"))
                {
                    args.Add("item");
                    args.Add("copyMask: copyMask");
                    args.Add("doMasks: false");
                    args.Add("errorMask: null");
                    args.Add("cmds: null");
                    args.Add("def: def");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static {this.ObjectName} Copy_ToLoqui{this.Mask_GenericClause(MaskType.Copy)}",
                wheres: this.GenericTypes_CopyMaskWheres))
            {
                args.Add($"{this.Getter_InterfaceStr} item");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                args.Add($"{this.Getter_InterfaceStr} def = null");
            }
            using (new BraceWrapper(fg))
            {
                if (this.Abstract)
                {
                    fg.AppendLine($"{this.ObjectName} ret = ({this.ObjectName})System.Activator.CreateInstance(item.GetType());");
                }
                else
                {
                    fg.AppendLine($"{this.ObjectName} ret;");
                    fg.AppendLine($"if (item.GetType().Equals(typeof({this.ObjectName})))");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"ret = new {this.ObjectName}() as {this.ObjectName};");
                    }
                    fg.AppendLine("else");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"ret = ({this.ObjectName})System.Activator.CreateInstance(item.GetType());");
                    }
                }
                using (var args = new ArgsWrapper(fg,
                    "ret.CopyFieldsFrom"))
                {
                    args.Add("item");
                    args.Add("copyMask: copyMask");
                    args.Add("def: def");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();
        }

        protected virtual void GenerateClear(FileGeneration fg, bool classFile)
        {
            if (classFile)
            {
                if (!HasBaseObject)
                {
                    fg.AppendLine("partial void ClearPartial(NotifyingUnsetParameters? cmds);");
                    fg.AppendLine();

                    fg.AppendLine("protected void CallClearPartial_Internal(NotifyingUnsetParameters? cmds)");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"ClearPartial(cmds);");
                    }
                    fg.AppendLine();
                }

                fg.AppendLine($"public{this.FunctionOverride()}void Clear(NotifyingUnsetParameters? cmds = null)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine("CallClearPartial_Internal(cmds);");
                    fg.AppendLine($"{this.ExtCommonName}.Clear(this, cmds);");
                }
                fg.AppendLine();
            }
            else
            {
                using (var args = new FunctionWrapper(fg,
                    $"public static void Clear{this.GenericTypes}",
                    GenerateWhereClauses().ToArray()))
                {
                    args.Add($"{this.InterfaceStr} item");
                    args.Add($"NotifyingUnsetParameters? cmds = null");
                }
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.ReadOnly) continue;
                        field.GenerateClear(fg, "item", "cmds");
                    }
                }
            }
            fg.AppendLine();
        }

        private void GenerateClear(FileGeneration fg, string accessor, string cmdAccessor)
        {
        }

        protected virtual void GenerateGenericCreate(FileGeneration fg)
        {
            if (!this.Abstract)
            {
                fg.AppendLine($"public{this.NewOverride}static {this.ObjectName} {Loqui.Internal.Constants.CREATE_FUNC_NAME}(IEnumerable<KeyValuePair<ushort, object>> fields)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"var ret = new {this.ObjectName}();");
                    fg.AppendLine($"foreach (var pair in fields)");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"CopyInInternal_{this.Name}(ret, pair);");
                    }
                    fg.AppendLine("return ret;");
                }
                fg.AppendLine();
            }

            fg.AppendLine($"protected{this.NewOverride}static void CopyInInternal_{this.Name}({this.ObjectName} obj, KeyValuePair<ushort, object> pair)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"if (!EnumExt.TryParse(pair.Key, out {this.FieldIndexName} enu))");
                using (new BraceWrapper(fg))
                {
                    if (this.HasBaseObject)
                    {
                        fg.AppendLine($"CopyInInternal_{this.BaseClass.Name}(obj, pair);");
                    }
                    else
                    {
                        fg.AppendLine("throw new ArgumentException($\"Unknown index: {pair.Key}\");");
                    }
                }
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.Derivative) continue;
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateSetNth(
                                fg,
                                accessorPrefix: $"obj",
                                rhsAccessorPrefix: $"({field.SetToName})pair.Value",
                                cmdsAccessor: "null",
                                internalUse: true);
                        }
                    }
                    fg.AppendLine("default:");
                    using (new DepthWrapper(fg))
                    {
                        fg.AppendLine("throw new ArgumentException($\"Unknown enum type: {enu}\");");
                    }
                }
            }

            fg.AppendLine($"public static void {Loqui.Internal.Constants.COPYIN_FUNC_NAME}(IEnumerable<KeyValuePair<ushort, object>> fields, {this.ObjectName} obj)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("ILoquiObjectExt.CopyFieldsIn(obj, fields, def: null, skipProtected: false, cmds: null);");
            }
            fg.AppendLine();
        }

        private void GenerateIsProtected(FileGeneration fg)
        {
            fg.AppendLine("public static bool IsProtected(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var trues = IterateFieldIndices().Where((i) => i.Field.ReadOnly);
                    var falses = IterateFieldIndices().Where((i) => !i.Field.ReadOnly);
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "IsProtected", "index", true);
                }
            }
            fg.AppendLine();
        }

        public void GenerateExceptionCatcher(FileGeneration fg, TypeGeneration field, string doErrMaskAccessor, string errorMaskAccessor, string enumAccessor)
        {
            fg.AppendLine("catch (Exception ex)");
            fg.AppendLine($"when ({doErrMaskAccessor})");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{errorMaskAccessor}().SetNthException((int){enumAccessor}, ex);");
            }
        }
        #endregion

        private async Task GenerateTranslations(FileGeneration fg)
        {
            if (this.gen.GenerationModules.Count == 0) return;
            using (new RegionWrapper(fg, "Modules"))
            {
                foreach (var translGen in this.gen.GenerationModules)
                {
                    using (new RegionWrapper(fg, translGen.RegionString))
                    {
                        await translGen.GenerateInVoid(this, fg);
                    }
                    fg.AppendLine();
                }

                await Task.WhenAll(this.gen.GenerationModules
                    .Select((g) => g.MiscellaneousGenerationActions(this)));
            }
        }

        private void GenerateLoquiInterfaces(FileGeneration fg)
        {
            if (this.gen.GenerationModules.Count == 0) return;
            using (new RegionWrapper(fg, "Loqui Interfaces"))
            {
                foreach (var interfGen in this.GenerationInterfaces)
                {
                    using (new RegionWrapper(fg, interfGen.RegionString))
                    {
                        interfGen.Generate(this, fg);
                    }
                }
            }
        }

        public bool HasLoquiInterface<T>()
            where T : GenerationInterface
        {
            return this.GenerationInterfaces.Any((i) => i.GetType().Equals(typeof(T)));
        }

        public string GetMaskString(string t)
        {
            if (t.Equals("Exception"))
            {
                return this.Mask(MaskType.Error);
            }
            else
            {
                var str = this.Name;
                str += "_Mask";
                str += $"<{t}>";
                return str;
            }
        }

        public virtual async Task Resolve()
        {
            foreach (var gen in this.Generics.Values)
            {
                if (!gen.Wheres.Any()) continue;
                if (!ObjectNamedKey.TryFactory(gen.Wheres.First(), this.ProtoGen.Protocol, out var objGenKey)) continue;
                if (!this.gen.ObjectGenerationsByObjectNameKey.TryGetValue(objGenKey, out var baseObjGen)) continue;
                gen.BaseObjectGeneration = baseObjGen;
            }

            await Task.WhenAll(this.IterateFields().ToList().Select((f) => f.Resolve()));

            if (this.HasRaisedPropertyChanged)
            {
                this.RequiredNamespaces.Add("System.ComponentModel");
                this.Interfaces.Add(nameof(INotifyPropertyChanged));
            }

            if (this.HasBaseObject)
            {
                AddBaseClassNamespaces(this);

                foreach (var baseGen in this.BaseClass.Generics)
                {
                    this.Generics.Add(baseGen.Key, baseGen.Value.Copy());
                    this.BaseGenerics[baseGen.Key] = baseGen.Key;
                }

                foreach (var baseGeneric in Node.Elements(XName.Get("BaseGeneric", LoquiGenerator.Namespace)))
                {
                    var genName = baseGeneric.GetAttribute("name");
                    var whereElem = baseGeneric.Elements(XName.Get("Where", LoquiGenerator.Namespace)).ToArray();
                    var definedElem = baseGeneric.Element(XName.Get("Defined", LoquiGenerator.Namespace));
                    if (whereElem.Any()
                        && definedElem != null)
                    {
                        throw new ArgumentException("Cannot define both Where and Defined nodes.");
                    }
                    if (whereElem.Any())
                    {
                        this.BaseGenerics[genName] = genName;
                        this.Generics[genName].Add(whereElem.Select((w) => w.Value));
                    }
                    else if (definedElem != null)
                    {
                        this.BaseGenerics[genName] = definedElem.Value;
                        this.Generics.Remove(genName);
                    }
                    else
                    {
                        throw new ArgumentException("Need to define Where or Defined node.");
                    }
                }
            }

            await Task.WhenAll(this.gen.GenerationModules.Select((mod) => mod.Resolve(this)));
        }

        private void AddBaseClassNamespaces(ObjectGeneration obj)
        {
            if (!obj.HasBaseObject) return;
            this.RequiredNamespaces.Add(obj.BaseClass.Namespace);
            this.RequiredNamespaces.Add(obj.BaseClass.InternalNamespace);
            AddBaseClassNamespaces(obj.BaseClass);
        }

        public void RegenerateAndStampSourceXML()
        {
            XDocument doc;
            using (var stream = new FileStream(this.SourceXMLFile.FullName, FileMode.Open))
            {
                doc = XDocument.Load(stream);
            }
            bool modified = false;

            var LoquiNode = doc.Element(XName.Get("Loqui", LoquiGenerator.Namespace));
            foreach (var obj in LoquiNode.Elements(XName.Get("Object", LoquiGenerator.Namespace))
                .And(LoquiNode.Elements(XName.Get("Struct", LoquiGenerator.Namespace))))
            {
                var name = obj.GetAttribute("name");
                if (name.Equals(this.Name))
                {
                    if (obj.GetAttribute("GUID") == null)
                    {
                        var guidAttr = new XAttribute("GUID", this.GUID.ToString());
                        obj.Add(guidAttr);
                        modified = true;
                    }
                    if (obj.GetAttribute("ID") == null)
                    {
                        var guidAttr = new XAttribute("ID", this.ID.ToString());
                        obj.Add(guidAttr);
                        modified = true;
                    }
                    break;
                }
            }

            if (!modified) return;

            using (var writer = new XmlTextWriter(
                new FileStream(this.SourceXMLFile.FullName, FileMode.Create), Encoding.ASCII))
            {
                writer.Formatting = Formatting.Indented;
                writer.Indentation = 2;
                doc.WriteTo(writer);
            }
        }

        public string Mask_Specified(MaskType type, GenericSpecification specifications)
        {
            return $"{this.Mask_BasicName(type)}{GenerateGenericClause(GenericTypes_Nickname(type, specifications.Specifications.ToArray()))}";
        }

        public string SpecifyGeneric(MaskType maskType, KeyValuePair<string, GenericDefinition> g, params KeyValuePair<string, string>[] specifications)
        {
            var specification = specifications.FirstOrDefault((spec) => spec.Key == g.Key);
            if (specification.Value == null)
            {
                string nickName;
                switch (maskType)
                {
                    case MaskType.Normal:
                        nickName = string.Empty;
                        break;
                    case MaskType.Error:
                        nickName = $"_{MaskModule.ErrMaskNickname}";
                        break;
                    case MaskType.Copy:
                        nickName = $"_{MaskModule.CopyMaskNickname}";
                        break;
                    default:
                        throw new NotImplementedException();
                }
                return $"{g.Key}{nickName}";
            }
            else
            {
                var nameKey = ObjectNamedKey.Factory(specification.Value, this.ProtoGen.Protocol);
                if (!this.ProtoGen.Gen.ObjectGenerationsByObjectNameKey.TryGetValue(
                   nameKey,
                   out var targetObj))
                {
                    throw new ArgumentException($"{nameKey} can not be located.");
                }
                return targetObj.Mask(maskType);
            }
        }

        public IEnumerable<string> GenericTypes_Nickname(MaskType maskType, params KeyValuePair<string, string>[] specifications)
        {
            return Generics.Where((g) => g.Value.BaseObjectGeneration != null).Select((g) =>
            {
                return SpecifyGeneric(maskType, g, specifications);
            });
        }

        public IEnumerable<string> BaseGenericTypes_Nickname(MaskType maskType, params KeyValuePair<string, string>[] specifications)
        {
            return Generics
                .Where((g) => g.Value.BaseObjectGeneration != null)
                .Where((g) => this.BaseGenerics.ContainsKey(g.Key))
                .Select((g) =>
                {
                    return SpecifyGeneric(maskType, g, specifications);
                });
        }

        public string Mask_BasicName(MaskType type)
        {
            switch (type)
            {
                case MaskType.Normal:
                    return $"{this.Name}_Mask";
                case MaskType.Error:
                    return $"{this.Name}_ErrorMask";
                case MaskType.Copy:
                    return $"{this.Name}_CopyMask";
                default:
                    throw new NotImplementedException();
            }
        }

        public string Mask(MaskType type)
        {
            switch (type)
            {
                case MaskType.Error:
                    return $"{this.Mask_BasicName(MaskType.Error)}{Mask_GenericClause(MaskType.Error)}";
                case MaskType.Copy:
                    return $"{this.Mask_BasicName(MaskType.Copy)}{Mask_GenericClause(MaskType.Copy)}";
                case MaskType.Normal:
                default:
                    throw new NotImplementedException();
            }
        }

        public IEnumerable<string> GenericTypes_Assumed(MaskType type, bool onlyAssumeSubclass = false)
        {
            return Generics
                .Where((g) => g.Value.BaseObjectGeneration != null)
                .Select((g) =>
                {
                    if (!onlyAssumeSubclass || !this.BaseGenerics.ContainsKey(g.Key))
                    {
                        return g.Value.BaseObjectGeneration.Mask(type);
                    }
                    else
                    {
                        return SpecifyGeneric(type, g);
                    }
                });
        }

        public string GenericClause_Assumed(MaskType type, bool onlyAssumeSubclass = false)
        {
            return GenerateGenericClause(GenericTypes_Assumed(type, onlyAssumeSubclass));
        }

        public string Mask_GenericAssumed(MaskType type, bool onlyAssumeSubclass = false)
        {
            return $"{this.Mask_BasicName(type)}{GenericClause_Assumed(type, onlyAssumeSubclass)}";
        }

        public string Mask_Unspecified(MaskType type)
        {
            return $"{this.Mask_BasicName(type)}{GenerateGenericClause(Generics.Where((g) => g.Value.BaseObjectGeneration != null).Select((g) => string.Empty))}";
        }

        public string BaseMask_GenericClausesAssumed(MaskType type)
        {
            return GenerateGenericClause(Generics.Where((g) => g.Value.BaseObjectGeneration != null).Select((g) => g.Value.BaseObjectGeneration.Mask(type)));
        }

        public string Mask_GenericClause(MaskType type) => GenerateGenericClause(GenericTypes_Nickname(type));

        public string BaseMask_GenericClause(MaskType type)
        {
            if (!this.HasBaseObject)
            {
                return Mask_GenericClause(type);
            }
            return GenerateGenericClause(Generics
                .Where((g) => g.Value.BaseObjectGeneration != null)
                .Where((g) => this.BaseGenerics.ContainsKey(g.Key))
                .Select((g) =>
                {
                    return SpecifyGeneric(type, g);
                }));
        }

        public IEnumerable<TypeGeneration> IterateFields(
            bool nonIntegrated = false,
            SetMarkerType.ExpandSets expandSets = SetMarkerType.ExpandSets.True)
        {
            return IterateFieldIndices(
                nonIntegrated: nonIntegrated,
                expandSets: expandSets).Select((f) => f.Field);
        }

        public IEnumerable<(int PublicIndex, int InternalIndex, TypeGeneration Field)> IterateFieldIndices(
            bool nonIntegrated = false,
            SetMarkerType.ExpandSets expandSets = SetMarkerType.ExpandSets.True,
            bool includeBaseClass = false)
        {
            if (includeBaseClass && this.HasBaseObject)
            {
                foreach (var item in this.BaseClass.IterateFieldIndices(
                    nonIntegrated: nonIntegrated,
                    expandSets: expandSets,
                    includeBaseClass: includeBaseClass))
                {
                    yield return item;
                }
            }
            int i = this.StartingIndex;
            for (int j = 0; j < this.Fields.Count; j++)
            {
                var field = this.Fields[j];
                if (!field.IntegrateField)
                {
                    if (field is SetMarkerType set)
                    {
                        switch (expandSets)
                        {
                            case SetMarkerType.ExpandSets.False:
                                continue;
                            case SetMarkerType.ExpandSets.FalseAndInclude:
                                yield return (-1, j, field);
                                continue;
                            case SetMarkerType.ExpandSets.True:
                            case SetMarkerType.ExpandSets.TrueAndInclude:
                                int k = 0;
                                foreach (var subField in set.IterateFields(
                                    nonIntegrated: nonIntegrated,
                                    expandSets: expandSets))
                                {
                                    yield return (subField.Index + i, j, subField.Field);
                                    k++;
                                }
                                i += k;
                                break;
                            default:
                                throw new NotImplementedException();
                        }
                        if (expandSets == SetMarkerType.ExpandSets.TrueAndInclude)
                        {
                            yield return (-1, j, field);
                        }
                    }
                    else if (nonIntegrated)
                    {
                        yield return (-1, j, field);
                    }
                }
                else
                {
                    yield return (i++, j, field);
                }
            }
        }

        public virtual string FunctionOverride(bool overrideIfAbstract = true)
        {
            return " ";
        }

        public IEnumerable<ObjectGeneration> BaseClassTrail()
        {
            if (!this.HasBaseObject) yield break;
            yield return this.BaseClass;
            foreach (var ret in this.BaseClass.BaseClassTrail())
            {
                yield return ret;
            }
        }

        public override string ToString()
        {
            return this.Name;
        }

        public void MarkFailure(Exception ex)
        {
            this._directlyInheritingObjectsTcs.TrySetException(ex);
            this.LoadingCompleteTask.TrySetException(ex);
            this.WiredBaseClassTCS.TrySetException(ex);
        }
    }
}
