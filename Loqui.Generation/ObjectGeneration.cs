using Loqui.Internal;
using Noggog;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;
#if NET_5
using TaskCompletionSource = TaskCompletionSource;
#else
using TaskCompletionSource = Noggog.TaskCompletionSource;
#endif

namespace Loqui.Generation
{
    public abstract class ObjectGeneration
    {
        public string Name;
        public string Namespace;
        public string InternalNamespace => $"{Namespace}.Internals";
        public string FullName => $"{Namespace}.{Name}";
        public abstract bool Abstract { get; }
        public DisabledLevel Disabled { get; set; }
        public bool GenerateClass { get; set; } = true;
        public bool GenerateEquals { get; set; } = true;
        public bool GenerateToString { get; set; } = true;
        public bool GenerateNthReflections { get; set; }
        public CtorPermissionLevel BasicCtorPermission { get; set; } = CtorPermissionLevel.@public;
        public abstract NotifyingType NotifyingDefault { get; }
        public abstract bool NullableDefault { get; }
        public LoquiInterfaceType SetterInterfaceTypeDefault;
        public LoquiInterfaceType GetterInterfaceTypeDefault;
        public bool ObjectCentralized;
        public PermissionLevel SetPermissionDefault;
        public RxBaseOption RxBaseOptionDefault;
        public bool DerivativeDefault;
        public int StartingIndex => this.HasLoquiBaseObject ? this.BaseClass.StartingIndex + this.BaseClass.IterateFields().Count() : 0;
        public int TotalFieldCount => this.StartingIndex + this.IterateFieldIndices().Count();
        public ClassGeneration BaseClass;
        public bool HasLoquiBaseObject => BaseClass != null;
        public bool SetBaseClass = true;
        public string NonLoquiBaseClass;
        public bool HasNonLoquiBaseObject => !string.IsNullOrWhiteSpace(this.NonLoquiBaseClass);
        public bool HasLoquiGenerics => this.Generics.Any((g) => g.Value.BaseObjectGeneration != null);
        public bool IsGeneric => this.Generics.Any();
        public bool HasNewGenerics => this.HasLoquiBaseObject && this.Generics.Any((g) => !this.BaseGenerics.ContainsKey(g.Key));
        public bool IsTopClass => BaseClass == null;
        public bool ForceInternalInterface = false;
        public InterfaceCollection Interfaces = new InterfaceCollection();
        public Dictionary<string, GenericDefinition> Generics = new Dictionary<string, GenericDefinition>();
        public string EmptyGenerics(params MaskType[] maskType) => GetEmptyGenerics(maskType);
        public Dictionary<string, string> BaseGenerics = new Dictionary<string, string>();
        public virtual string NewOverride(Func<ObjectGeneration, bool> baseObjFilter = null, bool doIt = true) => " ";
        public virtual string ProtectedKeyword => "protected";
        public ushort? ID;
        public Guid GUID;
        public ushort Version = 0;
        public XElement Node;
        public ObjectKey Key => new ObjectKey(ProtoGen.Protocol, ID.Value, Version);
        public string FileName => $"{this.Name}{Constants.AutogeneratedMarkerString}.cs";
        public bool NeedsReflectionGeneration => this.GenerateNthReflections;
        public bool GenerateComplexCopySystems => false;

        public bool HasInternalGetInterface
        {
            get
            {
                if (this.ForceInternalInterface) return true;
                if (this.IterateFields().Any(f => f.InternalGetInterface)) return true;
                return this.BaseClassTrail().Any(b => b.HasInternalGetInterface);
            }
        }
        public bool HasInternalSetInterface
        {
            get
            {
                if (this.ForceInternalInterface) return true;
                if (this.IterateFields().Any(f => f.InternalSetInterface)) return true;
                return this.BaseClassTrail().Any(b => b.HasInternalSetInterface);
            }
        }

        // String properties
        public string ObjectName => $"{this.Name}{this.GetGenericTypes(MaskType.Normal)}";
        public string ExtName => $"{Name}Ext";
        public string RegistrationName => $"{this.Name}_Registration";
        public string BaseGenericTypes => GenerateGenericClause(BaseGenerics.Select((g) => g.Value));
        public string BaseClassName => $"{this.BaseClass.Name}{this.BaseGenericTypes}";
        public string FieldIndexName => $"{this.Name}_FieldIndex";
        public string ProtocolDefinitionName => $"{this.ProtoGen.ProtocolDefinitionName}";
        public string CommonNameAdditions(LoquiInterfaceType loquiType, params MaskType[] types)
        {
            List<string> additions = new List<string>();
            switch (loquiType)
            {
                case LoquiInterfaceType.Direct:
                    additions.Add("Direct");
                    break;
                case LoquiInterfaceType.ISetter:
                    additions.Add("Setter");
                    break;
                case LoquiInterfaceType.IGetter:
                    break;
                default:
                    throw new NotImplementedException();
            }
            foreach (var mask in types.OrderBy(e => (int)e))
            {
                switch (mask)
                {
                    case MaskType.Normal:
                    case MaskType.NormalGetter:
                        break;
                    case MaskType.Error:
                        additions.Add(nameof(MaskType.Error));
                        break;
                    case MaskType.Copy:
                        additions.Add(nameof(MaskType.Copy));
                        break;
                    case MaskType.Translation:
                        additions.Add(nameof(MaskType.Translation));
                        break;
                    default:
                        throw new NotImplementedException();
                }
            }
            return string.Join(string.Empty, additions);
        }
        public string CommonClassName(LoquiInterfaceType interfaceType, params MaskType[] types) => $"{Name}{CommonNameAdditions(interfaceType, types)}Common";
        public string CommonClass(LoquiInterfaceType interfaceType, CommonGenerics commonGen, params MaskType[] types) => $"{this.CommonClassName(interfaceType, types)}{(commonGen == CommonGenerics.Class ? this.GetGenericTypes(types.Length == 0 ? new MaskType[] { MaskType.Normal } : types) : null)}";
        public string CommonClassInstance(Accessor accessor, LoquiInterfaceType interfaceType, CommonGenerics commonGen, params MaskType[] types) =>
            $"(({this.CommonClass(interfaceType, commonGen, types)})(({this.Interface(types, getter: true, internalInterface: false)}){accessor}).Common{CommonNameAdditions(interfaceType, types)}Instance({(commonGen == CommonGenerics.Class ? string.Join(", ", this.Generics.WithIndex().Select(x => $"typeof({x.Item.Key})")) : null)})!)";
        public string MixInClassName => $"{Name}MixIn";

        public DirectoryInfo TargetDir { get; private set; }
        public FileInfo SourceXMLFile { get; private set; }
        protected LoquiGenerator gen;
        public ProtocolGeneration ProtoGen;
        public HashSet<string> RequiredNamespaces = new HashSet<string>();
        public ExtendedList<GenerationInterface> GenerationInterfaces = new ExtendedList<GenerationInterface>();
        public ExtendedList<TypeGeneration> Fields = new ExtendedList<TypeGeneration>();
        public IEnumerable<TypeGeneration> AllFields => this.HasLoquiBaseObject ? this.Fields.And(this.BaseClass?.AllFields) : this.Fields;
        public Dictionary<FilePath, ProjItemType> GeneratedFiles = new Dictionary<FilePath, ProjItemType>();
        public Dictionary<object, object> CustomData = new Dictionary<object, object>();

        // Task Coordinators
        protected TaskCompletionSource<ExtendedList<ObjectGeneration>> _directlyInheritingObjectsTcs = new TaskCompletionSource<ExtendedList<ObjectGeneration>>();
        protected Task<ExtendedList<ObjectGeneration>> _directlyInheritingObjects => _directlyInheritingObjectsTcs.Task;
        public async Task<IEnumerable<ObjectGeneration>> InheritingObjects()
        {
            List<ObjectGeneration> ret = new List<ObjectGeneration>();
            var objs = await _directlyInheritingObjects;
            ret.AddRange(objs);
            ret.AddRange((await Task.WhenAll(
                objs.Select(async (o) => await o.InheritingObjects()))).SelectMany((i) => i));
            return ret;
        }
        public TaskCompletionSource LoadingCompleteTask = new TaskCompletionSource();
        protected TaskCompletionSource WiredBaseClassTCS = new TaskCompletionSource();
        public Task WiredBaseClassTask => WiredBaseClassTCS.Task;
        protected TaskCompletionSource fieldCtorsGenerated = new TaskCompletionSource();
        public Task FieldCtorsGeneratedSignal => fieldCtorsGenerated.Task;
        private TaskCompletionSource<MaskTypeSetCollection> _MaskTypeSetCollection = new TaskCompletionSource<MaskTypeSetCollection>();
        public Task<MaskTypeSetCollection> MaskTypeSetCollection => _MaskTypeSetCollection.Task;

        public CommentCollection Comments;

        public ObjectGeneration(LoquiGenerator gen, ProtocolGeneration protoGen, FileInfo sourceFile)
        {
            this.gen = gen;
            this.ProtoGen = protoGen;
            this.TargetDir = sourceFile.Directory;
            this.SourceXMLFile = sourceFile;
            this.SetterInterfaceTypeDefault = this.ProtoGen.SetterInterfaceTypeDefault;
            this.GetterInterfaceTypeDefault = this.ProtoGen.GetterInterfaceTypeDefault;
            this.SetPermissionDefault = this.ProtoGen.SetPermissionDefault;
            this.RxBaseOptionDefault = this.ProtoGen.RxBaseOptionDefault;
            this.DerivativeDefault = this.ProtoGen.DerivativeDefault;
            this.GenerateNthReflections = this.ProtoGen.NthReflectionDefault;
            this.GenerateToString = this.ProtoGen.ToStringDefault;
            this.Disabled = DisabledLevel.Enabled;

            RequiredNamespaces.Add("System");
            RequiredNamespaces.Add("System.Collections");
            RequiredNamespaces.Add("System.Collections.Generic");
            RequiredNamespaces.Add("System.Linq");
            RequiredNamespaces.Add("System.Text");
            RequiredNamespaces.Add("Loqui");
            RequiredNamespaces.Add("Loqui.Internal");
            RequiredNamespaces.Add("Noggog");
            RequiredNamespaces.Add("System.Diagnostics");
        }

        public virtual async Task Load()
        {
            Node.TransferAttribute<bool>(Constants.GENERATE_CLASS, (i) => GenerateClass = i);
            Node.TransferAttribute<bool>(Constants.GENERATE_EQUALS, (i) => GenerateEquals = i);
            Node.TransferAttribute<bool>(Constants.GENERATE_TO_STRING, (i) => GenerateToString = i);
            Node.TransferAttribute<CtorPermissionLevel>(Constants.CTOR_PERMISSION, (i) => BasicCtorPermission = i);
            Node.TransferAttribute<ushort>(Constants.VERSION, (i) => Version = i);
            Node.TransferAttribute<bool>(Constants.FORCE_INTERNAL_INTERFACE, (i) => this.ForceInternalInterface = i);
            Node.TransferAttribute<LoquiInterfaceType>(Constants.SET_INTERFACE_TYPE_DEFAULT, (i) => this.SetterInterfaceTypeDefault = i);
            Node.TransferAttribute<LoquiInterfaceType>(Constants.GET_INTERFACE_TYPE_DEFAULT, (i) => this.GetterInterfaceTypeDefault = i);
            Node.TransferAttribute<PermissionLevel>(Constants.SET_PERMISSION_DEFAULT, (i) => this.SetPermissionDefault = i);
            Node.TransferAttribute<bool>(Constants.DERIVATIVE_DEFAULT, (i) => this.DerivativeDefault = i);
            Node.TransferAttribute<DisabledLevel>(Constants.DISABLE, (i) => this.Disabled = i);
            Node.TransferAttribute<bool>(Constants.SET_BASE_CLASS, i => this.SetBaseClass = i);

            var namespacesNode = Node.Element(XName.Get(Constants.NAMESPACES, LoquiGenerator.Namespace));
            if (namespacesNode != null)
            {
                foreach (var node in namespacesNode.Elements())
                {
                    if (!string.IsNullOrWhiteSpace(node.Value))
                    {
                        this.RequiredNamespaces.Add(node.Value);
                    }
                }
            }
            RequiredNamespaces.Add(InternalNamespace);

            foreach (var genNode in Node.Elements(XName.Get(Constants.GENERIC, LoquiGenerator.Namespace)))
            {
                var generic = new GenericDefinition();
                generic.Load(genNode);
                this.Generics[generic.Name] = generic;
            }

            foreach (var interfNode in Node.Elements(XName.Get(Constants.INTERFACE, LoquiGenerator.Namespace)))
            {
                Interfaces.Add(interfNode.GetAttribute<LoquiInterfaceDefinitionType>(Constants.TYPE, LoquiInterfaceDefinitionType.Dual), interfNode.Value);
            }

            var fieldsNode = Node.Element(XName.Get(Constants.FIELDS, LoquiGenerator.Namespace));
            if (fieldsNode != null)
            {
                foreach (var fieldNode in fieldsNode.Elements())
                {
                    await LoadField(
                        fieldNode,
                        requireName: true,
                        add: true);
                }
            }

            foreach (var interf in this.GenerationInterfaces)
            {
                interf.Modify(this);
            }

            var directlyInheritingObjs = new ExtendedList<ObjectGeneration>();
            await Task.WhenAll(
                this.ProtoGen.Gen.ObjectGenerations.Select(
                    async (obj) =>
                    {
                        await obj.WiredBaseClassTask;
                        if (!obj.HasLoquiBaseObject) return;
                        if (!object.ReferenceEquals(obj.BaseClass, this)) return;
                        directlyInheritingObjs.Add(obj);
                    }));
            this._directlyInheritingObjectsTcs.SetResult(directlyInheritingObjs);

            await Task.WhenAll(
                this.gen.GenerationModules.Select((m) => m.LoadWrapup(this)));
        }

        public async Task<TryGet<TypeGeneration>> LoadField(XElement fieldNode, bool requireName, bool throwException = true, bool setDefaults = true, bool add = false)
        {
            if (fieldNode.NodeType == System.Xml.XmlNodeType.Comment)
            {
                return TryGet<TypeGeneration>.Failure;
            }

            if (!gen.TryGetTypeGeneration(fieldNode.Name.LocalName, out var typeGen))
            {
                if (throwException)
                {
                    throw new ArgumentException($"Unknown field type: {fieldNode.Name.LocalName}");
                }
                else
                {
                    return TryGet<TypeGeneration>.Failure;
                }
            }

            typeGen.SetObjectGeneration(this, setDefaults: setDefaults);
            await typeGen.Load(fieldNode, requireName);
            await LoadField(typeGen, fieldNode, add: add);
            return TryGet<TypeGeneration>.Succeed(typeGen);
        }

        public async Task LoadField(TypeGeneration typeGen, XElement fieldNode = null, bool add = true)
        {
            if (this.Fields.Any((f) => f.Name?.Equals(typeGen.Name) ?? false))
            {
                throw new ArgumentException($"Cannot have two fields with the same name: {typeGen.Name}");
            }
            if (add)
            {
                typeGen.SetObjectGeneration(this, setDefaults: true);
                this.Fields.Add(typeGen);
            }
            await Task.WhenAll(this.gen.GenerationModules.Select((m) => m.PostFieldLoad(this, typeGen, fieldNode)));
            typeGen.FinalizeField();
        }

        public static void AddAutogenerationComment(FileGeneration fg)
        {
            fg.AppendLine("/*");
            fg.AppendLine(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");
            fg.AppendLine(" * Autogenerated by Loqui.  Do not manually change.");
            fg.AppendLine(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ");
            fg.AppendLine("*/");
        }

        public async Task Generate()
        {
            if (this.Disabled != DisabledLevel.Enabled) return;
            FileGeneration fg = new FileGeneration();
            AddAutogenerationComment(fg);

            await AddNamespaces(fg);
            fg.AppendLine("#nullable enable");

            using (new NamespaceWrapper(fg, this.Namespace))
            {
                if (GenerateClass)
                {
                    await GenerateClassFile(fg);
                }

                await GenerateInterfaces(fg);

                await GenerateMixIns(fg);
            }
            fg.AppendLine();

            using (new NamespaceWrapper(fg, this.InternalNamespace))
            {
                GenerateEnumIndex(fg);
                await GenerateRegistration(fg);
                await GenerateCommon(fg);
                GenerateLoquiInterfaces(fg);
            }
            fg.AppendLine();

            using (new NamespaceWrapper(fg, this.Namespace))
            {
                fg.AppendLine($"public partial class {this.ObjectName}");
                using (new BraceWrapper(fg))
                {
                    await this.GenerateRouting(fg, getterOnly: false);
                }
            }
            fg.AppendLine();

            await GenerateTranslations(fg);
            await GenerateNonGenericClass(fg);

            var fileName = Path.Combine(TargetDir.FullName, FileName);
            var file = new FileInfo(fileName);
            this.GeneratedFiles[Path.GetFullPath(fileName)] = ProjItemType.Compile;
            fg.Generate(file);
            if (!this.gen.GeneratedFiles.Add(fileName))
            {
                throw new ArgumentException();
            }
        }

        public bool HasKeyField()
        {
            foreach (var field in this.IterateFields())
            {
                if (field.KeyField) return true;
            }
            if (this.HasLoquiBaseObject)
            {
                return this.BaseClass.HasKeyField();
            }
            return false;
        }

        public static string GenerateGenericClause(params string[] keys)
        {
            return GenerateGenericClause((IEnumerable<string>)keys);
        }

        public static string GenerateGenericClause(params IEnumerable<string>[] keys)
        {
            return GenerateGenericClause(keys.SelectMany((i) => i));
        }

        public static string GenerateGenericClause(IEnumerable<string> keys)
        {
            if (!keys.Any()) return string.Empty;
            return $"<{string.Join(", ", keys)}>";
        }

        public IEnumerable<string> GenerateWhereClauses(LoquiInterfaceType type, IEnumerable<KeyValuePair<string, GenericDefinition>> defs = null, string nickname = null)
        {
            foreach (var gen in (defs ?? this.Generics))
            {
                List<string> wheres = new List<string>();
                if (gen.Value.MustBeClass
                    && (gen.Value.BaseObjectGeneration == null || type != LoquiInterfaceType.Direct))
                {
                    wheres.Add("class");
                }
                wheres.AddRange(gen.Value.GetWheres(type));
                if (gen.Value.Loqui && gen.Value.BaseObjectGeneration == null)
                {
                    switch (type)
                    {
                        case LoquiInterfaceType.IGetter:
                            wheres.Add($"{nameof(ILoquiObject)}<{gen.Key}>");
                            break;
                        case LoquiInterfaceType.Direct:
                        case LoquiInterfaceType.ISetter:
                            wheres.Add($"{nameof(ILoquiObjectSetter)}<{gen.Key}>");
                            break;
                        default:
                            throw new NotImplementedException();
                    }
                }
                if (wheres.Count > 0)
                {
                    yield return $"where {gen.Key}{nickname} : {string.Join(", ", wheres)}";
                }
            }
        }

        public void GenerateForField(FileGeneration fg, TypeGeneration field)
        {
            if (!field.GenerateClassMembers) return;
            using (new RegionWrapper(fg, field.Name) { AppendExtraLine = false })
            {
                field.GenerateForClass(fg);
                foreach (var module in this.gen.GenerationModules)
                {
                    module.GenerateInField(this, field, fg, LoquiInterfaceType.Direct);
                }
            }
        }

        private async Task GenerateClassFile(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Class"))
            {
                if (Comments != null)
                {
                    Comments.Comments.Apply(fg);
                }
                await GenerateClassLine(fg);

                using (new DepthWrapper(fg))
                {
                    foreach (var where in this.GenerateWhereClauses(LoquiInterfaceType.ISetter, this.Generics))
                    {
                        fg.AppendLine(where);
                    }
                }

                using (new BraceWrapper(fg))
                {
                    await GenerateCtor(fg);

                    await GenerateStaticCtor(fg);
                    // Generate fields
                    foreach (var field in this.IterateFieldIndices())
                    {
                        GenerateForField(fg, field.Field);
                    }
                    fg.AppendLine();

                    if (this.GenerateNthReflections)
                    {
                        await GenerateLoquiReflectionGetterInterface(fg);

                        await GenerateLoquiReflectionSetterInterface(fg);
                    }

                    await GenerateToStringCode(fg);

                    GenerateEqualsSection(fg);

                    await GenerateModules(fg);

                    GenerateGetterInterfaceImplementations(fg);

                    GenerateInterfacesInClass(fg);

                    GenerateClear(fg);

                    await GenerateCreateNew(fg);

                    if (this.GenerateNthReflections)
                    {
                        await GenerateSetNthObject(fg);

                        GenerateGenericCreate(fg);
                    }
                }
            }
        }

        public async Task GenerateInitializer(FileGeneration fg)
        {
            foreach (var loqui in this.Fields
                .WhereCastable<TypeGeneration, LoquiType>()
                .Where(l => l.ThisConstruction))
            {
                if (loqui.Singleton)
                {
                    fg.AppendLine($"{loqui.SingletonObjectName} = new {loqui.DirectTypeName}(this);");
                }
                else
                {
                    fg.AppendLine($"_{loqui.Name} = new {loqui.DirectTypeName}(this);");
                }
            }
        }

        private async Task GenerateInterfaces(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Interface"))
            {
                await GenerateSetterInterface(fg);
                await GenerateGetterInterface(fg);
            }
        }

        protected virtual async Task GenerateMixIns(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Common MixIn"))
            {
                using (var args = new ClassWrapper(fg, $"{this.MixInClassName}"))
                {
                    args.Static = true;
                    args.Partial = true;
                }
                using (new BraceWrapper(fg))
                {
                    await GenerateClearMixIn(fg);
                    await GenerateGetEqualsMaskMixIn(fg);
                    await GenerateToStringMixIn(fg);
                    await GenerateEqualsMixIn(fg);
                    if (this.GenerateComplexCopySystems)
                    {
                        await GenerateCopyInExtensions(fg);
                        GenerateCopyMixIn(fg);
                    }
                    await GenerateDeepCopyInExtensions(fg);
                    GenerateDeepCopyMixIn(fg);

                    // Modules might add some content
                    foreach (var mod in this.gen.GenerationModules)
                    {
                        using (new RegionWrapper(fg, mod.RegionString))
                        {
                            await mod.GenerateInCommonMixin(this, fg);
                        }
                    }
                }
            }
        }

        protected virtual async Task GenerateSetterInterface(FileGeneration fg)
        {
            var interfaceLine = Interface(
                genericTypes: GenerateGenericClause(Generics.Select((g) => g.Value.SetterName)),
                getter: false,
                internalInterface: false);

            // Interface
            if (Comments != null)
            {
                (Comments.SetterInterface ?? Comments.Comments).Apply(fg);
            }
            using (var args = new ClassWrapper(fg, interfaceLine))
            {
                args.Type = ClassWrapper.ObjectType.@interface;
                args.Partial = true;
                args.Interfaces.Add(this.Interface(getter: true, internalInterface: true));
                if (this.HasLoquiBaseObject)
                {
                    args.Interfaces.Add(this.BaseClass.Interface(this.BaseGenericTypes, internalInterface: false));
                }
                args.Interfaces.Add(this.Interfaces.Get(LoquiInterfaceType.ISetter));
                args.Interfaces.Add($"{nameof(ILoquiObjectSetter)}<{this.Interface(internalInterface: true)}>");
                args.Interfaces.Add(await this.GetApplicableInterfaces(LoquiInterfaceType.ISetter).ToListAsync());
                args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.ISetter, Generics));
            }
            using (new BraceWrapper(fg))
            {
                foreach (var field in this.IterateFields())
                {
                    field.GenerateForInterface(fg, getter: false, internalInterface: false);
                }

                foreach (var mod in this.gen.GenerationModules)
                {
                    using (new RegionWrapper(fg, mod.RegionString))
                    {
                        await mod.GenerateInInterface(this, fg, internalInterface: false, getter: false);
                    }
                }
            }
            fg.AppendLine();

            if (this.HasInternalSetInterface)
            {
                // Internal Interface
                using (var args = new ClassWrapper(fg, this.Interface(internalInterface: true)))
                {
                    args.Type = ClassWrapper.ObjectType.@interface;
                    args.Partial = true;
                    args.BaseClass = this.BaseClassTrail().FirstOrDefault(b => b.HasInternalSetInterface)?.Interface(internalInterface: true);
                    args.Interfaces.Add(this.Interface(internalInterface: false));
                    args.Interfaces.Add(this.Interface(getter: true, internalInterface: true));
                    args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.ISetter, Generics));
                }
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        field.GenerateForInterface(fg, getter: false, internalInterface: true);
                    }

                    foreach (var mod in this.gen.GenerationModules)
                    {
                        using (new RegionWrapper(fg, mod.RegionString))
                        {
                            await mod.GenerateInInterface(this, fg, internalInterface: true, getter: false);
                        }
                    }
                }
                fg.AppendLine();
            }
        }

        protected virtual async Task GenerateGetterInterface(FileGeneration fg)
        {
            var interfaceLine = Interface(
                genericTypes: GenerateGenericClause(Generics.Select((g) => g.Value.GetterName)),
                getter: true,
                internalInterface: false);

            // Getter
            if (Comments != null)
            {
                (Comments.GetterInterface ?? Comments.Comments).Apply(fg);
            }
            using (var args = new ClassWrapper(fg, interfaceLine))
            {
                args.Type = ClassWrapper.ObjectType.@interface;
                args.Partial = true;
                args.BaseClass = (this.HasLoquiBaseObject ? this.BaseClass.Interface(this.BaseGenericTypes, getter: true, internalInterface: false) : nameof(ILoquiObject));
                args.Interfaces.Add(this.Interfaces.Get(LoquiInterfaceType.IGetter));
                args.Interfaces.Add($"{nameof(ILoquiObject)}<{this.Interface(getter: true, internalInterface: true)}>");
                args.Interfaces.Add(await this.GetApplicableInterfaces(LoquiInterfaceType.IGetter).ToListAsync());
                args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.IGetter, Generics));
            }

            using (new BraceWrapper(fg))
            {
                if (this.IsTopClass)
                {
                    fg.AppendLine("[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]");
                    fg.AppendLine($"object Common{this.CommonNameAdditions(LoquiInterfaceType.IGetter)}Instance({string.Join(", ", this.Generics.WithIndex().Select(x => $"Type type{x.Index}"))});");
                    fg.AppendLine("[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]");
                    fg.AppendLine($"object? Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal)}Instance({string.Join(", ", this.Generics.WithIndex().Select(x => $"Type type{x.Index}"))});");
                    if (this.GenerateComplexCopySystems)
                    {
                        fg.AppendLine("[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]");
                        using (var args = new FunctionWrapper(fg,
                            $"object Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy)}Instance{this.GetGenericTypes(MaskType.Copy)}"))
                        {
                            args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Copy));
                            args.SemiColon = true;
                        }
                    }
                    fg.AppendLine("[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]");
                    fg.AppendLine($"object Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Translation)}Instance();");
                }
                fg.AppendLine($"static{NewOverride()}{nameof(ILoquiRegistration)} Registration => {this.RegistrationName}.Instance;");
                foreach (var field in this.IterateFields())
                {
                    using (new RegionWrapper(fg, field.Name)
                    {
                        AppendExtraLine = false,
                        SkipIfOnlyOneLine = true
                    })
                    {
                        field.GenerateForInterface(fg, getter: true, internalInterface: false);
                    }
                }
                fg.AppendLine();

                foreach (var mod in this.gen.GenerationModules)
                {
                    using (new RegionWrapper(fg, mod.RegionString))
                    {
                        await mod.GenerateInInterface(this, fg, internalInterface: false, getter: true);
                    }
                }
            }
            fg.AppendLine();

            if (this.HasInternalGetInterface)
            {
                // Internal Getter
                interfaceLine = Interface(
                    genericTypes: GenerateGenericClause(Generics.Select((g) => g.Value.GetterName)),
                    getter: true,
                    internalInterface: true);
                using (var args = new ClassWrapper(fg, interfaceLine))
                {
                    args.Type = ClassWrapper.ObjectType.@interface;
                    args.Partial = true;
                    args.BaseClass = this.BaseClassTrail().FirstOrDefault()?.Interface(internalInterface: true, getter: true);
                    args.Interfaces.Add(this.Interface(getter: true, internalInterface: false));
                    args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.IGetter, Generics));
                }
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (!field.InternalGetInterface) continue;
                        using (new RegionWrapper(fg, field.Name) { AppendExtraLine = false })
                        {
                            field.GenerateForInterface(fg, getter: true, internalInterface: true);
                        }
                    }
                    fg.AppendLine();

                    foreach (var mod in this.gen.GenerationModules)
                    {
                        using (new RegionWrapper(fg, mod.RegionString))
                        {
                            await mod.GenerateInInterface(this, fg, internalInterface: true, getter: true);
                        }
                    }
                    fg.AppendLine();
                }
            }
        }

        protected void GenerateEnumIndex(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Field Index"))
            {
                fg.AppendLine($"public enum {this.FieldIndexName}");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFieldIndices(includeBaseClass: true))
                    {
                        if (!field.Field.IntegrateField || !field.Field.Enabled) continue;
                        fg.AppendLine($"{field.Field.Name} = {field.PublicIndex},");
                    }
                }
            }
        }

        protected async Task GenerateRegistration(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Registration"))
            {
                using (var args = new ClassWrapper(fg, this.RegistrationName))
                {
                    args.Interfaces.Add(nameof(ILoquiRegistration));
                    args.Partial = true;
                    args.Public = PermissionLevel.@public;
                }
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"public static readonly {this.RegistrationName} Instance = new {this.RegistrationName}();");
                    fg.AppendLine();

                    fg.AppendLine($"public static ProtocolKey ProtocolKey => {this.ProtocolDefinitionName}.ProtocolKey;");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly ObjectKey ObjectKey = new ObjectKey(");
                    using (new DepthWrapper(fg))
                    {
                        fg.AppendLine($"protocolKey: {this.ProtocolDefinitionName}.ProtocolKey,");
                        fg.AppendLine($"msgID: {this.ID},");
                        fg.AppendLine($"version: {this.Version});");
                    }
                    fg.AppendLine();

                    fg.AppendLine($"public const string GUID = \"{this.GUID}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const ushort AdditionalFieldCount = {this.IterateFields().Count()};");
                    fg.AppendLine();

                    fg.AppendLine($"public const ushort FieldCount = {this.TotalFieldCount};");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type MaskType = typeof({this.GetMaskString("")});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type ErrorMaskType = typeof({this.Mask_Unspecified(MaskType.Error)});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type ClassType = typeof({this.Name}{this.EmptyGenerics()});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type GetterType = typeof({this.InterfaceNoGenerics(getter: true)}{this.EmptyGenerics()});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type? InternalGetterType = {(this.HasInternalGetInterface ? $"typeof({this.InterfaceNoGenerics(getter: true, internalInterface: true)}{this.EmptyGenerics()})" : "null")};");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type SetterType = typeof({this.InterfaceNoGenerics()}{this.EmptyGenerics()});");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type? InternalSetterType = {(this.HasInternalSetInterface ? $"typeof({this.InterfaceNoGenerics(internalInterface: true)}{this.EmptyGenerics()})" : "null")};");
                    fg.AppendLine();

                    fg.AppendLine($"public const string FullName = \"{this.FullName}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const string Name = \"{this.Name}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const string Namespace = \"{this.Namespace}\";");
                    fg.AppendLine();

                    fg.AppendLine($"public const byte GenericCount = {this.Generics.Count};");
                    fg.AppendLine();

                    fg.AppendLine($"public static readonly Type? GenericRegistrationType = {(this.Generics.Count > 0 ? $"typeof({this.RegistrationName}{this.EmptyGenerics()})" : "null")};");
                    fg.AppendLine();

                    if (GenerateNthReflections)
                    {
                        GenerateGetNameIndex(fg);

                        GenerateNthObjectIsEnumerable(fg);

                        GenerateNthObjectIsLoqui(fg);

                        GenerateGetNthIsSingleton(fg);

                        GenerateGetNthName(fg);

                        GenerateNthObjectIsDerivative(fg);

                        GenerateIsProtected(fg);

                        if (this.Generics.Count == 0)
                        {
                            GenerateGetNthType(fg, false);
                        }
                        else
                        {
                            fg.AppendLine("public static Type GetNthType(ushort index) => throw new ArgumentException(\"Cannot get nth type for a generic object here.  Use generic registration instead.\");");
                            fg.AppendLine();
                        }
                    }

                    foreach (var mod in this.gen.GenerationModules)
                    {
                        await mod.GenerateInRegistration(this, fg);
                    }

                    foreach (var field in this.Fields)
                    {
                        field.GenerateInRegistration(fg);
                    }

                    using (new RegionWrapper(fg, "Interface"))
                    {
                        fg.AppendLine($"ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;");
                        fg.AppendLine($"ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;");
                        fg.AppendLine($"string ILoquiRegistration.GUID => GUID;");
                        fg.AppendLine($"ushort ILoquiRegistration.FieldCount => FieldCount;");
                        fg.AppendLine($"ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;");
                        fg.AppendLine($"Type ILoquiRegistration.MaskType => MaskType;");
                        fg.AppendLine($"Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;");
                        fg.AppendLine($"Type ILoquiRegistration.ClassType => ClassType;");
                        fg.AppendLine($"Type ILoquiRegistration.SetterType => SetterType;");
                        fg.AppendLine($"Type? ILoquiRegistration.InternalSetterType => InternalSetterType;");
                        fg.AppendLine($"Type ILoquiRegistration.GetterType => GetterType;");
                        fg.AppendLine($"Type? ILoquiRegistration.InternalGetterType => InternalGetterType;");
                        fg.AppendLine($"string ILoquiRegistration.FullName => FullName;");
                        fg.AppendLine($"string ILoquiRegistration.Name => Name;");
                        fg.AppendLine($"string ILoquiRegistration.Namespace => Namespace;");
                        fg.AppendLine($"byte ILoquiRegistration.GenericCount => GenericCount;");
                        fg.AppendLine($"Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;");
                        if (GenerateNthReflections)
                        {
                            fg.AppendLine($"ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => GetNameIndex(name);");
                            fg.AppendLine($"bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => GetNthIsEnumerable(index);");
                            fg.AppendLine($"bool ILoquiRegistration.GetNthIsLoqui(ushort index) => GetNthIsLoqui(index);");
                            fg.AppendLine($"bool ILoquiRegistration.GetNthIsSingleton(ushort index) => GetNthIsSingleton(index);");
                            fg.AppendLine($"string ILoquiRegistration.GetNthName(ushort index) => GetNthName(index);");
                            fg.AppendLine($"bool ILoquiRegistration.IsNthDerivative(ushort index) => IsNthDerivative(index);");
                            fg.AppendLine($"bool ILoquiRegistration.IsProtected(ushort index) => IsProtected(index);");
                            fg.AppendLine($"Type ILoquiRegistration.GetNthType(ushort index) => GetNthType(index);");
                        }
                        else
                        {
                            fg.AppendLine($"ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();");
                            fg.AppendLine($"bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();");
                            fg.AppendLine($"bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();");
                            fg.AppendLine($"bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();");
                            fg.AppendLine($"string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();");
                            fg.AppendLine($"bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();");
                            fg.AppendLine($"bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();");
                            fg.AppendLine($"Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();");
                        }
                    }
                }

                if (this.Generics.Count > 0)
                {
                    fg.AppendLine();
                    using (var args = new ClassWrapper(fg, $"{this.RegistrationName}{this.GetGenericTypes(MaskType.Normal)}"))
                    {
                        args.Interfaces.Add(this.RegistrationName);
                        args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.Direct, Generics));
                    }
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"public static readonly {this.RegistrationName}{this.GetGenericTypes(MaskType.Normal)} GenericInstance = new {this.RegistrationName}{this.GetGenericTypes(MaskType.Normal)}();");
                        fg.AppendLine();

                        GenerateGetNthType(fg, true);
                    }
                }
            }
        }

        private async Task GenerateCommon(FileGeneration fg)
        {
            MaskTypeSetCollection activeMaskCollections = new MaskTypeSetCollection();
            using (new RegionWrapper(fg, "Common"))
            {
                await GenerateCommonClass(fg, activeMaskCollections, LoquiInterfaceType.ISetter, CommonGenerics.Class, MaskType.Normal);
                await GenerateCommonClass(fg, activeMaskCollections, LoquiInterfaceType.IGetter, CommonGenerics.Class, MaskType.Normal);
                await GenerateCommonClass(fg, activeMaskCollections, LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Copy);
                await GenerateCommonClass(fg, activeMaskCollections, LoquiInterfaceType.IGetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Copy);
                await GenerateCommonClass(fg, activeMaskCollections, LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Translation);
            }
            _MaskTypeSetCollection.SetResult(activeMaskCollections);
        }

        private async Task GenerateCommonClass(FileGeneration fg, MaskTypeSetCollection activeMaskCollections, LoquiInterfaceType interfaceType, CommonGenerics commonGen, params MaskType[] maskTypes)
        {
            bool acceptAll = false;
            var maskTypeCol = new MaskTypeSet(interfaceType, maskTypes, commonGen: commonGen, acceptAll: acceptAll);
            if (acceptAll && !maskTypeCol.IsMainSet) return;

            FileGeneration subGen = new FileGeneration();

            if (this.GenerateComplexCopySystems)
            {
                GenerateCopyInCommon(subGen, maskTypeCol);
            }

            GenerateDeepCopyInCommon(subGen, maskTypeCol);

            if (this.GenerateNthReflections)
            {
                GenerateUnsetNthObject(subGen, maskTypeCol);

                GenerateGetNthObject(subGen, maskTypeCol);
            }

            await GenerateClearCommon(subGen, maskTypeCol);

            GenerateGetEqualsMask(subGen, maskTypeCol);

            GenerateCommonToString(subGen, maskTypeCol);

            GenerateFieldIndexConverters(subGen, this, maskTypeCol);

            GenerateEqualsCommon(subGen, maskTypeCol);

            await GenerateCreateNewBasicCommon(subGen, maskTypeCol);

            if (this.GenerateComplexCopySystems)
            {
                GenerateCopy(subGen, maskTypeCol);
            }

            GenerateDeepCopy(subGen, maskTypeCol);

            // Fields might add some content
            foreach (var field in this.IterateFields())
            {
                field.GenerateInCommon(subGen, maskTypeCol);
            }

            // Modules might add some content
            foreach (var mod in this.gen.GenerationModules)
            {
                using (new RegionWrapper(subGen, mod.RegionString))
                {
                    await mod.GenerateInCommon(this, subGen, maskTypeCol);
                }
            }

            if (subGen.Empty) return;

            var classGen = commonGen == CommonGenerics.Class;
            var className = $"{this.CommonClassName(interfaceType, maskTypes)}{(classGen ? this.GetGenericTypes(maskTypes) : null)}";
            using (var args = new ClassWrapper(fg, className))
            {
                if (classGen)
                {
                    args.Wheres.AddRange(this.GenericTypeMaskWheres(interfaceType, maskTypes));
                }
                args.Partial = true;
                if (this.HasLoquiBaseObject)
                {
                    args.BaseClass = $"{this.BaseClass.CommonClassName(interfaceType, maskTypes)}{(classGen ? this.BaseClass.GetGenericTypes(maskTypes) : null)}";
                }
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"public{this.NewOverride()}static readonly {className} Instance = new {className}();");
                fg.AppendLine();

                fg.AppendLines(subGen);
            }
            activeMaskCollections.Add(maskTypeCol);
        }

        private async Task GenerateToStringMixIn(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static string ToString{this.GetGenericTypes(MaskType.Normal)}"))
            {
                args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.IGetter));
                args.Add($"this {this.Interface(getter: true, internalInterface: true)} item");
                args.Add($"string? name = null");
                args.Add($"{this.GetMaskString("bool")}? printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return {this.CommonClassInstance("item", LoquiInterfaceType.IGetter, CommonGenerics.Class)}.ToString"))
                {
                    args.Add("item: item");
                    args.Add("name: name");
                    args.Add("printMask: printMask");
                }
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static void ToString{this.GetGenericTypes(MaskType.Normal)}"))
            {
                args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.IGetter));
                args.Add($"this {this.Interface(getter: true, internalInterface: true)} item");
                args.Add($"{nameof(FileGeneration)} fg");
                args.Add($"string? name = null");
                args.Add($"{this.GetMaskString("bool")}? printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClassInstance("item", LoquiInterfaceType.IGetter, CommonGenerics.Class)}.ToString"))
                {
                    args.Add("item: item");
                    args.Add("fg: fg");
                    args.Add("name: name");
                    args.Add("printMask: printMask");
                }
            }
            fg.AppendLine();
        }

        private void GenerateCommonToString(FileGeneration fg, MaskTypeSet maskTypes)
        {
            if (!maskTypes.Applicable(LoquiInterfaceType.IGetter, CommonGenerics.Class)) return;
            using (var args = new FunctionWrapper(fg,
                $"public string ToString"))
            {
                args.Add($"{this.Interface(getter: true, internalInterface: true)} item");
                args.Add($"string? name = null");
                args.Add($"{this.GetMaskString("bool")}? printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var fg = new {nameof(FileGeneration)}();");
                using (var args = new ArgsWrapper(fg,
                    $"ToString"))
                {
                    args.Add("item: item");
                    args.Add("fg: fg");
                    args.Add("name: name");
                    args.Add("printMask: printMask");
                }
                fg.AppendLine("return fg.ToString();");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public void ToString"))
            {
                args.Add($"{this.Interface(getter: true, internalInterface: true)} item");
                args.Add($"{nameof(FileGeneration)} fg");
                args.Add($"string? name = null");
                args.Add($"{this.GetMaskString("bool")}? printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                string generics = "";
                if (this.Generics.Any())
                {
                    generics = $"<{string.Join(", ", Generics.Select((g) => g.Key).Select(gen => $"{{typeof({gen}).Name}}"))}>";
                }
                fg.AppendLine("if (name == null)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"fg.AppendLine($\"{this.Name}{generics} =>\");");
                }
                fg.AppendLine("else");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"fg.AppendLine($\"{{name}} ({this.Name}{generics}) =>\");");
                }
                fg.AppendLine($"fg.AppendLine(\"[\");");
                fg.AppendLine($"using (new DepthWrapper(fg))");
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        $"ToStringFields"))
                    {
                        args.Add("item: item");
                        args.Add("fg: fg");
                        args.Add("printMask: printMask");
                    }
                }
                fg.AppendLine($"fg.AppendLine(\"]\");");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"protected static void ToStringFields"))
            {
                args.Add($"{this.Interface(getter: true, internalInterface: true)} item");
                args.Add($"{nameof(FileGeneration)} fg");
                args.Add($"{this.GetMaskString("bool")}? printMask = null");
            }
            using (new BraceWrapper(fg))
            {
                if (this.HasLoquiBaseObject)
                {
                    using (var args = new ArgsWrapper(fg,
                        $"{this.BaseClass.CommonClass(LoquiInterfaceType.IGetter, CommonGenerics.Class)}.ToStringFields"))
                    {
                        args.Add("item: item");
                        args.Add("fg: fg");
                        args.Add("printMask: printMask");
                    }
                }
                foreach (var field in this.IterateFields())
                {
                    if (!field.IntegrateField) continue;
                    Accessor accessor = Accessor.FromType(field, "item");
                    using (var ifArgs = new IfWrapper(fg, ANDs: true))
                    {
                        ifArgs.Add(gen.MaskModule.GetMaskModule(field.GetType()).GenerateBoolMaskCheck(field, "printMask"), wrapInParens: true);
                        if (field.Nullable && field.CanBeNullable(getter: true))
                        {
                            ifArgs.Add($"item.{field.Name}.TryGet(out var {field.Name}Item)");
                            accessor = $"{field.Name}Item";
                        }
                        ifArgs.Body = (subFg) => field.GenerateToString(subFg, field.Name, accessor, "fg");
                    }
                }
            }
            fg.AppendLine();
        }

        private void GenerateFieldIndexConverters(FileGeneration fg, ObjectGeneration obj, MaskTypeSet maskTypes, bool first = true)
        {
            if (!maskTypes.Applicable(LoquiInterfaceType.IGetter, CommonGenerics.Class)) return;
            if (!obj.HasLoquiBaseObject) return;
            var baseObj = obj.BaseClass;
            using (var args = new FunctionWrapper(fg,
                $"public static{this.NewOverride(doIt: !first)}{this.FieldIndexName} ConvertFieldIndex"))
            {
                args.Add($"{baseObj.FieldIndexName} index");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("switch (index)");
                using (new BraceWrapper(fg))
                {
                    foreach (var (PublicIndex, InternalIndex, Field) in baseObj.IterateFieldIndices(includeBaseClass: true))
                    {
                        fg.AppendLine($"case {baseObj.FieldIndexName}.{Field.Name}:");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"return ({this.FieldIndexName})((int)index);");
                        }
                    }

                    fg.AppendLine("default:");
                    using (new DepthWrapper(fg))
                    {
                        GenerateIndexOutOfRangeEx(fg, $"index.{nameof(EnumExt.ToStringFast_Enum_Only)}()");
                    }
                }
            }
            fg.AppendLine();
            GenerateFieldIndexConverters(fg, baseObj, maskTypes, first: false);
        }

        protected virtual async Task GenerateCopyInExtensions(FileGeneration fg)
        {
            if (this.IsTopClass)
            {
                using (var args = new FunctionWrapper(fg,
                    $"public static void CopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.Copy)}"))
                {
                    if (this.IsTopClass)
                    {
                        args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy));
                    }
                    args.Add($"this {this.ObjectName} lhs");
                    args.Add($"{(this.BaseClassTrail().LastOrDefault() ?? this).ObjectName} rhs");
                }
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        $"CopyIn{GenerateGenericClause(GenericTypes_Nickname(MaskType.Normal), GenericTypes_Assumed(MaskType.Error), GenericTypes_Nickname(MaskType.Copy))}"))
                    {
                        args.AddPassArg($"lhs");
                        args.AddPassArg($"rhs");
                        args.Add("doMasks: false");
                        args.Add($"errorMask: out var errMask");
                        args.Add("copyMask: null");
                    }
                }
                fg.AppendLine();
            }

            using (var args = new FunctionWrapper(fg,
                $"public static void CopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.Copy)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy));
                args.Add($"this {this.ObjectName} lhs");
                args.Add($"{this.ObjectName} rhs");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"CopyIn{GenerateGenericClause(GenericTypes_Nickname(MaskType.Normal), GenericTypes_Assumed(MaskType.Error), GenericTypes_Nickname(MaskType.Copy))}"))
                {
                    args.AddPassArg($"lhs");
                    args.AddPassArg($"rhs");
                    args.Add("doMasks: false");
                    args.Add("errorMask: out var errMask");
                    args.AddPassArg("copyMask");
                }
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static void CopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.Error, MaskType.Copy)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Error, MaskType.Copy));
                args.Add($"this {this.ObjectName} lhs");
                args.Add($"{this.ObjectName} rhs");
                args.Add($"out {this.Mask(MaskType.Error)} errorMask");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
                args.Add($"bool doMasks = true");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var errorMaskBuilder = doMasks ? new ErrorMaskBuilder() : null;");
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClassInstance("lhs", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Copy)}.CopyIn"))
                {
                    args.Add("item: lhs");
                    args.AddPassArg($"rhs");
                    args.Add("errorMask: errorMaskBuilder");
                    args.AddPassArg($"copyMask");
                }
                fg.AppendLine($"errorMask = {this.Mask(MaskType.Error)}.Factory(errorMaskBuilder);");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static void CopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.Copy)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy));
                args.Add($"this {this.ObjectName} lhs");
                args.Add($"{this.ObjectName} rhs");
                args.Add($"ErrorMaskBuilder errorMask");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClassInstance("lhs", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Copy)}.CopyIn"))
                {
                    args.Add("item: lhs");
                    args.AddPassArg($"rhs");
                    args.AddPassArg($"errorMask");
                    args.AddPassArg($"copyMask");
                }
            }
            fg.AppendLine();
        }

        protected virtual async Task GenerateDeepCopyInExtensions(FileGeneration fg)
        {
            if (this.IsTopClass)
            {
                using (var args = new FunctionWrapper(fg,
                    $"public static void DeepCopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter)}"))
                {
                    if (this.IsTopClass)
                    {
                        args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter));
                    }
                    args.Add($"this {this.Interface(getter: false, internalInterface: true)} lhs");
                    args.Add($"{(this.BaseClassTrail().LastOrDefault() ?? this).Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} rhs");
                }
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        $"{this.CommonClassInstance("lhs", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Translation)}.DeepCopyIn{GenerateGenericClause(GenericTypes_Nickname(MaskType.Normal), GenericTypes_Nickname(MaskType.NormalGetter))}"))
                    {
                        args.Add("item: lhs");
                        args.AddPassArg($"rhs");
                        args.Add("errorMask: default");
                        args.Add($"copyMask: default");
                        args.Add($"deepCopy: false");
                    }
                }
                fg.AppendLine();

                using (var args = new FunctionWrapper(fg,
                    $"public static void DeepCopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter, MaskType.Translation)}"))
                {
                    if (this.IsTopClass)
                    {
                        args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter, MaskType.Translation));
                    }
                    args.Add($"this {this.Interface(getter: false, internalInterface: true)} lhs");
                    args.Add($"{(this.BaseClassTrail().LastOrDefault() ?? this).Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} rhs");
                    args.Add($"{this.Mask(MaskType.Translation)}? copyMask = null");
                }
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        $"{this.CommonClassInstance("lhs", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Translation)}.DeepCopyIn{GenerateGenericClause(GenericTypes_Nickname(MaskType.Normal), GenericTypes_Nickname(MaskType.NormalGetter))}"))
                    {
                        args.Add("item: lhs");
                        args.AddPassArg($"rhs");
                        args.Add("errorMask: default");
                        args.Add($"copyMask: copyMask?.GetCrystal()");
                        args.Add($"deepCopy: false");
                    }
                }
                fg.AppendLine();
            }

            using (var args = new FunctionWrapper(fg,
                $"public static void DeepCopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter, MaskType.Error, MaskType.Translation)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter, MaskType.Error, MaskType.Translation));
                args.Add($"this {this.Interface(getter: false, internalInterface: true)} lhs");
                args.Add($"{this.Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} rhs");
                args.Add($"out {this.Mask(MaskType.Error)} errorMask");
                args.Add($"{this.Mask(MaskType.Translation)}? copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var errorMaskBuilder = new ErrorMaskBuilder();");
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClassInstance("lhs", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Translation)}.DeepCopyIn{GenerateGenericClause(GenericTypes_Nickname(MaskType.Normal), GenericTypes_Nickname(MaskType.NormalGetter))}"))
                {
                    args.Add("item: lhs");
                    args.AddPassArg($"rhs");
                    args.Add("errorMask: errorMaskBuilder");
                    args.Add($"copyMask: copyMask?.GetCrystal()");
                    args.Add($"deepCopy: false");
                }
                fg.AppendLine($"errorMask = {this.Mask(MaskType.Error)}.Factory(errorMaskBuilder);");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static void DeepCopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter));
                args.Add($"this {this.Interface(getter: false, internalInterface: true)} lhs");
                args.Add($"{this.Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} rhs");
                args.Add($"ErrorMaskBuilder? errorMask");
                args.Add($"TranslationCrystal? copyMask");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClassInstance("lhs", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Translation)}.DeepCopyIn{GenerateGenericClause(GenericTypes_Nickname(MaskType.Normal), GenericTypes_Nickname(MaskType.NormalGetter))}"))
                {
                    args.Add("item: lhs");
                    args.AddPassArg($"rhs");
                    args.AddPassArg($"errorMask");
                    args.AddPassArg($"copyMask");
                    args.Add($"deepCopy: false");
                }
            }
            fg.AppendLine();
        }

        protected virtual async Task GenerateDeepCopyIn(FileGeneration fg)
        {
            if (this.IsTopClass)
            {
                using (var args = new FunctionWrapper(fg,
                    $"public void DeepCopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.Translation)}"))
                {
                    if (this.IsTopClass)
                    {
                        args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Translation));
                    }
                    args.Add($"this {this.Interface(getter: false)} lhs");
                    args.Add($"{(this.BaseClassTrail().LastOrDefault() ?? this).Interface(getter: true)} rhs");
                }
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        $"DeepCopyIn{GenerateGenericClause(GenericTypes_Nickname(MaskType.Normal), GenericTypes_Assumed(MaskType.Error), GenericTypes_Nickname(MaskType.Translation))}"))
                    {
                        args.AddPassArg($"lhs");
                        args.AddPassArg($"rhs");
                        args.Add("doMasks: false");
                        args.Add($"errorMask: out var errMask");
                        args.Add("copyMask: null");
                    }
                }
                fg.AppendLine();
            }

            using (var args = new FunctionWrapper(fg,
                $"public void DeepCopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.Translation)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Translation));
                args.Add($"this {this.Interface(getter: false)} lhs");
                args.Add($"{this.Interface(getter: true)} rhs");
                args.Add($"{this.Mask(MaskType.Translation)} copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"DeepCopyIn{GenerateGenericClause(GenericTypes_Nickname(MaskType.Normal), GenericTypes_Assumed(MaskType.Error), GenericTypes_Nickname(MaskType.Translation))}"))
                {
                    args.AddPassArg($"lhs");
                    args.AddPassArg($"rhs");
                    args.Add("doMasks: false");
                    args.Add("errorMask: out var errMask");
                    args.AddPassArg("copyMask");
                }
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public void DeepCopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.Error, MaskType.Translation)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Error, MaskType.Translation));
                args.Add($"this {this.Interface(false)} lhs");
                args.Add($"{this.Interface(true)} rhs");
                args.Add($"out {this.Mask(MaskType.Error)} errorMask");
                args.Add($"{this.Mask(MaskType.Translation)} copyMask = null");
                args.Add($"bool doMasks = true");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var errorMaskBuilder = new ErrorMaskBuilder();");
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClass(LoquiInterfaceType.IGetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Translation)}.DeepCopyIn"))
                {
                    args.Add("item: lhs");
                    args.AddPassArg($"rhs");
                    args.Add("errorMask: errorMaskBuilder");
                    args.AddPassArg($"copyMask");
                }
                fg.AppendLine($"errorMask = {this.Mask(MaskType.Error)}.Factory(errorMaskBuilder);");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public void DeepCopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.Translation)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Translation));
                args.Add($"this {this.Interface(getter: false)} lhs");
                args.Add($"{this.Interface(getter: true)} rhs");
                args.Add($"ErrorMaskBuilder errorMask");
                args.Add($"{this.Mask(MaskType.Translation)} copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClass(LoquiInterfaceType.IGetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Translation)}.DeepCopyIn"))
                {
                    args.Add("item: lhs");
                    args.AddPassArg($"rhs");
                    args.AddPassArg($"errorMask");
                    args.AddPassArg($"copyMask");
                }
            }
            fg.AppendLine();
        }

        protected virtual void GenerateCopyInCommon(FileGeneration fg, MaskTypeSet maskTypes)
        {
            if (!maskTypes.Applicable(LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Copy)) return;
            throw new NotImplementedException();
            //using (new RegionWrapper(fg, "Copy Fields From"))
            //{
            //    using (var args = new FunctionWrapper(fg,
            //        $"public void CopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.Copy)}"))
            //    {
            //        args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy));
            //        args.Add($"{this.ObjectName} item");
            //        args.Add($"{this.ObjectName} rhs");
            //        args.Add($"ErrorMaskBuilder errorMask");
            //        args.Add($"{this.Mask(MaskType.Copy)} copyMask");
            //    }
            //    using (new BraceWrapper(fg))
            //    {
            //        GenerateCopyForFields(
            //            fg,
            //            "item",
            //            "rhs",
            //            errMaskAccessor: "errorMask",
            //            copyMaskAccessor: "copyMask",
            //            deepCopy: false);
            //    }
            //    fg.AppendLine();
            //}
        }

        protected virtual void GenerateDeepCopyInCommon(FileGeneration fg, MaskTypeSet maskTypes)
        {
            if (!maskTypes.Applicable(LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Translation)) return;

            using (new RegionWrapper(fg, "DeepCopyIn"))
            {
                if (this.HasInternalGetInterface || this.HasInternalSetInterface)
                {
                    using (var args = new FunctionWrapper(fg,
                        $"public{this.Virtual()}void DeepCopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter)}"))
                    {
                        args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter));
                        args.Add($"{this.Interface(getter: false, internalInterface: true)} item");
                        args.Add($"{this.Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} rhs");
                        args.Add($"ErrorMaskBuilder? errorMask");
                        args.Add($"TranslationCrystal? copyMask");
                        args.Add($"bool deepCopy");
                    }
                    using (new BraceWrapper(fg))
                    {
                        GenerateCopyForFields(
                            fg,
                            "item",
                            "rhs",
                            errMaskAccessor: "errorMask",
                            copyMaskAccessor: "copyMask",
                            deepCopy: true,
                            internalCopy: true);
                        if (!this.BaseClassTrail().Any(b => b.HasInternalGetInterface || b.HasInternalSetInterface))
                        {
                            using (var args = new ArgsWrapper(fg,
                                $"DeepCopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter)}"))
                            {
                                args.Add($"({this.Interface(getter: false)})item");
                                args.Add($"({this.Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true)})rhs");
                                args.AddPassArg("errorMask");
                                args.AddPassArg("copyMask");
                                args.AddPassArg("deepCopy");
                            }
                        }
                    }
                    fg.AppendLine();
                }

                using (var args = new FunctionWrapper(fg,
                    $"public{this.Virtual()}void DeepCopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter)}"))
                {
                    args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter));
                    args.Add($"{this.Interface(getter: false)} item");
                    args.Add($"{this.Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true)} rhs");
                    args.Add($"ErrorMaskBuilder? errorMask");
                    args.Add($"TranslationCrystal? copyMask");
                    args.Add($"bool deepCopy");
                }
                using (new BraceWrapper(fg))
                {
                    GenerateCopyForFields(
                        fg,
                        "item",
                        "rhs",
                        errMaskAccessor: "errorMask",
                        copyMaskAccessor: "copyMask",
                        deepCopy: true,
                        internalCopy: false);
                }
                fg.AppendLine();

                foreach (var baseClass in this.BaseClassTrail())
                {
                    if (baseClass.HasInternalGetInterface || baseClass.HasInternalSetInterface)
                    {
                        using (var args = new FunctionWrapper(fg,
                            $"public override void DeepCopyIn{baseClass.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter)}"))
                        {
                            args.Wheres.AddRange(baseClass.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter));
                            args.Add($"{baseClass.Interface(getter: false, internalInterface: true)} item");
                            args.Add($"{baseClass.Interface(baseClass.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} rhs");
                            args.Add($"ErrorMaskBuilder? errorMask");
                            args.Add($"TranslationCrystal? copyMask");
                            args.Add($"bool deepCopy");
                        }
                        using (new BraceWrapper(fg))
                        {
                            using (var args = new ArgsWrapper(fg,
                                $"this.DeepCopyIn"))
                            {
                                args.Add($"item: ({this.Interface(getter: false, internalInterface: true)})item");
                                args.Add($"rhs: ({this.Interface(baseClass.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)})rhs");
                                args.AddPassArg("errorMask");
                                args.AddPassArg("copyMask");
                                args.AddPassArg("deepCopy");
                            }
                        }
                    }
                    fg.AppendLine();

                    using (var args = new FunctionWrapper(fg,
                        $"public override void DeepCopyIn{baseClass.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter)}"))
                    {
                        args.Wheres.AddRange(baseClass.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter));
                        args.Add($"{baseClass.Interface(getter: false)} item");
                        args.Add($"{baseClass.Interface(baseClass.GetGenericTypes(MaskType.NormalGetter), getter: true)} rhs");
                        args.Add($"ErrorMaskBuilder? errorMask");
                        args.Add($"TranslationCrystal? copyMask");
                        args.Add($"bool deepCopy");
                    }
                    using (new BraceWrapper(fg))
                    {
                        using (var args = new ArgsWrapper(fg,
                            $"this.DeepCopyIn"))
                        {
                            args.Add($"item: ({this.Interface(getter: false)})item");
                            args.Add($"rhs: ({this.Interface(baseClass.GetGenericTypes(MaskType.NormalGetter), getter: true)})rhs");
                            args.AddPassArg("errorMask");
                            args.AddPassArg("copyMask");
                            args.AddPassArg("deepCopy");
                        }
                    }
                    fg.AppendLine();
                }
            }
        }

        private void GenerateCopyForFields(
            FileGeneration fg,
            string accessorPrefix,
            string rhsAccessorPrefix,
            string errMaskAccessor,
            string copyMaskAccessor,
            bool deepCopy,
            bool internalCopy)
        {
            if (this.HasLoquiBaseObject)
            {
                var funcStr = deepCopy
                    ? $"base.DeepCopyIn{this.GetBaseGenericTypes(MaskType.Normal)}"
                    : $"base.CopyIn{this.GetBaseGenericTypes(MaskType.Normal, MaskType.Copy)}";
                using (var args = new ArgsWrapper(fg, funcStr))
                {
                    args.Add($"{(internalCopy ? null : $"({this.BaseClass.Interface(getter: false, internalInterface: false)})")}{accessorPrefix}");
                    args.Add($"{(internalCopy ? null : $"({this.BaseClass.Interface(getter: true, internalInterface: false)})")}{rhsAccessorPrefix}");
                    args.Add(errMaskAccessor);
                    args.Add(copyMaskAccessor);
                    args.AddPassArg("deepCopy");
                }
            }

            foreach (var item in this.IterateFieldIndices(nonIntegrated: true))
            {
                if (item.Field.CopyLevel == CopyLevel.None) continue;
                var internalField = item.Field.InternalGetInterface || item.Field.InternalSetInterface;
                if (internalField != internalCopy) continue;
                if (!item.Field.Enabled) continue;

                if (item.Field.CopyLevel == CopyLevel.DeepCopyOnly)
                {
                    fg.AppendLine("if (deepCopy)");
                }
                using (new BraceWrapper(fg, doIt: item.Field.CopyLevel == CopyLevel.DeepCopyOnly))
                {
                    item.Field.GenerateForCopy(
                        fg,
                        Accessor.FromType(item.Field, accessorPrefix),
                        Accessor.FromType(item.Field, rhsAccessorPrefix),
                        deepCopy ? copyMaskAccessor : Accessor.FromType(item.Field, copyMaskAccessor, nullable: TypeExt.IsNullable(item.Field.GetType())),
                        protectedMembers: false,
                        deepCopy: deepCopy);
                }
            }
        }

        #region Generation Snippets
        public async Task GenerateRouting(FileGeneration fg, bool getterOnly)
        {
            MaskTypeSetCollection maskSets = await this.MaskTypeSetCollection;
            using (new RegionWrapper(fg, "Common Routing"))
            {
                // ToDo
                // Eventually detect and generate all applicable combinations

                var typeInParams = $"{string.Join(", ", this.Generics.WithIndex().Select(x => $"Type type{x.Index}"))}";
                var typeOutParams = $"{string.Join(", ", this.Generics.WithIndex().Select(x => $"type{x.Index}"))}";

                string AddGenericWrap(string instance)
                {
                    if (!this.IsGeneric) return instance;
                    if (this.Generics.Count != 1)
                    {
                        throw new NotImplementedException();
                    }
                    return $"{nameof(GenericCommonInstanceGetter)}.{nameof(GenericCommonInstanceGetter.Get)}({instance}, typeof({this.Generics.First().Key}), type0)";
                }

                fg.AppendLine($"[DebuggerBrowsable(DebuggerBrowsableState.Never)]");
                fg.AppendLine($"ILoquiRegistration ILoquiObject.Registration => {this.RegistrationName}.Instance;");
                fg.AppendLine($"public{NewOverride()}static {this.RegistrationName} Registration => {this.RegistrationName}.Instance;");
                fg.AppendLine("[DebuggerStepThrough]");
                fg.AppendLine($"protected{this.FunctionOverride()}object Common{this.CommonNameAdditions(LoquiInterfaceType.IGetter, MaskType.Normal)}Instance({typeInParams}) => {AddGenericWrap($"{CommonClassRouter(maskSets, LoquiInterfaceType.IGetter, CommonGenerics.Class, MaskType.Normal)}.Instance")};");
                if (!getterOnly)
                {
                    fg.AppendLine("[DebuggerStepThrough]");
                    using (var args = new FunctionWrapper(fg,
                        $"protected{this.FunctionOverride()}object Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal)}Instance"))
                    {
                        if (!string.IsNullOrWhiteSpace(typeInParams))
                        {
                            args.Add(typeInParams);
                        }
                    }
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"return {AddGenericWrap($"{CommonClassRouter(maskSets, LoquiInterfaceType.ISetter, CommonGenerics.Class, MaskType.Normal)}.Instance")};");
                    }
                    if (this.GenerateComplexCopySystems)
                    {
                        fg.AppendLine("[DebuggerStepThrough]");
                        using (var args = new FunctionWrapper(fg,
                            $"protected{this.FunctionOverride()}object Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy)}Instance{this.GetGenericTypes(MaskType.Copy)}"))
                        {
                            if (this.IsTopClass)
                            {
                                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, maskTypes: MaskType.Copy));
                            }
                            if (!string.IsNullOrWhiteSpace(typeInParams))
                            {
                                args.Add(typeInParams);
                            }
                        }
                        using (new BraceWrapper(fg))
                        {
                            fg.AppendLine($"return {CommonClassRouter(maskSets, LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Copy)}.Instance;");
                        }
                    }
                }
                fg.AppendLine("[DebuggerStepThrough]");
                fg.AppendLine($"protected{this.FunctionOverride()}object Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Translation)}Instance() => {CommonClassRouter(maskSets, LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Translation)}.Instance;");
                if (this.IsTopClass)
                {
                    fg.AppendLine("[DebuggerStepThrough]");
                    fg.AppendLine($"object {this.Interface(getter: true, internalInterface: false)}.Common{this.CommonNameAdditions(LoquiInterfaceType.IGetter)}Instance({typeInParams}) => this.Common{this.CommonNameAdditions(LoquiInterfaceType.IGetter)}Instance({typeOutParams});");
                    if (getterOnly)
                    {
                        fg.AppendLine("[DebuggerStepThrough]");
                        fg.AppendLine($"object? {this.Interface(getter: true, internalInterface: false)}.Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter)}Instance({typeInParams}) => null;");
                        if (this.GenerateComplexCopySystems)
                        {
                            fg.AppendLine("[DebuggerStepThrough]");
                            fg.AppendLine($"object {this.Interface(getter: true, internalInterface: false)}.Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy)}Instance{this.GetGenericTypes(MaskType.Copy)}({typeInParams}) => null;");
                        }
                    }
                    else
                    {
                        fg.AppendLine("[DebuggerStepThrough]");
                        fg.AppendLine($"object {this.Interface(getter: true, internalInterface: false)}.Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter)}Instance({typeInParams}) => this.Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter)}Instance({typeOutParams});");
                        if (this.GenerateComplexCopySystems)
                        {
                            fg.AppendLine("[DebuggerStepThrough]");
                            fg.AppendLine($"object {this.Interface(getter: true, internalInterface: false)}.Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy)}Instance{this.GetGenericTypes(MaskType.Copy)}({typeInParams}) => this.Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy)}Instance{this.GetGenericTypes(MaskType.Copy)}({typeOutParams});");
                        }
                    }
                    fg.AppendLine("[DebuggerStepThrough]");
                    fg.AppendLine($"object {this.Interface(getter: true, internalInterface: false)}.Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Translation)}Instance() => this.Common{this.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Translation)}Instance();");
                }
                fg.AppendLine();

                foreach (var associatedObj in this.Interfaces
                    .Select(i => i.AssociatedObject)
                    .NotNull()
                    .Distinct())
                {
                    fg.AppendLine("[DebuggerStepThrough]");
                    fg.AppendLine($"object {associatedObj.Interface(getter: true, internalInterface: false)}.Common{associatedObj.CommonNameAdditions(LoquiInterfaceType.IGetter)}Instance() => {associatedObj.CommonClassRouter(maskSets, LoquiInterfaceType.IGetter, CommonGenerics.Class, MaskType.Normal)}.Instance;");
                    if (getterOnly)
                    {
                        fg.AppendLine("[DebuggerStepThrough]");
                        fg.AppendLine($"object? {associatedObj.Interface(getter: true, internalInterface: false)}.Common{associatedObj.CommonNameAdditions(LoquiInterfaceType.ISetter)}Instance() => null;");
                        if (associatedObj.GenerateComplexCopySystems)
                        {
                            fg.AppendLine("[DebuggerStepThrough]");
                            fg.AppendLine($"object {associatedObj.Interface(getter: true, internalInterface: false)}.Common{associatedObj.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy)}Instance{associatedObj.GetGenericTypes(MaskType.Copy)}() => null;");
                        }
                    }
                    else
                    {
                        fg.AppendLine("[DebuggerStepThrough]");
                        fg.AppendLine($"object {associatedObj.Interface(getter: true, internalInterface: false)}.Common{associatedObj.CommonNameAdditions(LoquiInterfaceType.ISetter)}Instance() => {associatedObj.CommonClassRouter(maskSets, LoquiInterfaceType.ISetter, CommonGenerics.Class, MaskType.Normal)}.Instance;");
                        if (associatedObj.GenerateComplexCopySystems)
                        {
                            fg.AppendLine("[DebuggerStepThrough]");
                            fg.AppendLine($"object {associatedObj.Interface(getter: true, internalInterface: false)}.Common{associatedObj.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy)}Instance{associatedObj.GetGenericTypes(MaskType.Copy)}() => {associatedObj.CommonClassRouter(maskSets, LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Copy)}.Instance;");
                        }
                    }
                    fg.AppendLine("[DebuggerStepThrough]");
                    fg.AppendLine($"object {associatedObj.Interface(getter: true, internalInterface: false)}.Common{associatedObj.CommonNameAdditions(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Translation)}Instance() => {associatedObj.CommonClassRouter(maskSets, LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Translation)}.Instance;");
                    fg.AppendLine();
                }
            }
        }

        public string CommonClassRouter(MaskTypeSetCollection maskSets, LoquiInterfaceType interfaceType, CommonGenerics commonGen, params MaskType[] maskTypes)
        {
            // ToDo Eventually route into one common class if only that needed
            //if (maskSets.Contains(interfaceType, maskTypes))
            {
                return this.CommonClass(interfaceType, commonGen, maskTypes);
            }
            //else
            //{ // Fallback
            //    return this.CommonClass(LoquiInterfaceType.IGetter, MaskType.Normal);
            //}
        }

        protected abstract Task GenerateCtor(FileGeneration fg);

        protected async Task GenerateStaticCtor(FileGeneration fg)
        {
            FileGeneration staticCtorFG = new FileGeneration();
            foreach (var mod in this.gen.GenerationModules)
            {
                await mod.GenerateInStaticCtor(this, staticCtorFG);
            }
            foreach (var field in this.IterateFields())
            {
                field.GenerateForStaticCtor(staticCtorFG);
            }
            if (staticCtorFG.Empty) return;
            fg.AppendLine($"static {this.Name}()");
            using (new BraceWrapper(fg))
            {
                fg.AppendLines(staticCtorFG);
            }
            fg.AppendLine();
        }

        protected abstract Task GenerateClassLine(FileGeneration fg);

        public async Task GenerateLoquiReflectionGetterInterface(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Loqui Getter Interface"))
            {
                fg.AppendLine();

                fg.AppendLine($"protected{this.FunctionOverride()}object GetNthObject(ushort index) => {this.CommonClassName(LoquiInterfaceType.IGetter)}.GetNthObject{this.GetGenericTypes(MaskType.Normal)}(index, this);");
                if (this.IsTopClass)
                {
                    fg.AppendLine($"object {nameof(ILoquiReflectionGetter)}.GetNthObject(ushort index) => this.GetNthObject(index);");
                }
                fg.AppendLine();

                fg.AppendLine($"protected{this.FunctionOverride()}void UnsetNthObject(ushort index) => {this.CommonClassName(LoquiInterfaceType.ISetter)}.UnsetNthObject{this.GetGenericTypes(MaskType.Normal)}(index, this);");
                if (this.IsTopClass)
                {
                    fg.AppendLine($"void {nameof(ILoquiReflectionSetter)}.UnsetNthObject(ushort index) => this.UnsetNthObject(index);");
                }
                fg.AppendLine();
            }
        }

        protected virtual async Task GenerateLoquiReflectionSetterInterface(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "Loqui Interface"))
            {
            }
        }

        private void GenerateGetNthObject(FileGeneration fg, MaskTypeSet maskTypes)
        {
            if (!maskTypes.Applicable(LoquiInterfaceType.IGetter, CommonGenerics.Class)) return;
            using (var args = new FunctionWrapper(fg,
                $"public static object GetNthObject"))
            {
                args.Add($"ushort index");
                args.Add($"{this.Interface(getter: true)} obj");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNth(fg, Accessor.FromType(field, "obj"));
                        }
                    }

                    GenerateStandardIndexDefault(fg, LoquiInterfaceType.IGetter, "GetNthObject", "index", true, true, "obj");
                }
            }
            fg.AppendLine();
        }

        protected virtual async Task GenerateSetNthObject(FileGeneration fg)
        {
            if (this.IsTopClass && this.GenerateNthReflections)
            {
                fg.AppendLine($"void {nameof(ILoquiReflectionSetter)}.SetNthObject(ushort index, object obj) => this.SetNthObject(index, obj);");
            }
            fg.AppendLine($"protected{this.FunctionOverride()}void SetNthObject(ushort index, object obj)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var derivatives = IterateFieldIndices()
                        .Where((f) => f.Field.Derivative).ToList();
                    if (derivatives.Count > 0)
                    {
                        foreach (var item in derivatives)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("throw new ArgumentException($\"Tried to set at a derivative index {index}\");");
                        }
                    }
                    foreach (var field in this.IterateFields())
                    {
                        if (field.Derivative) continue;
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateSetNth(
                                fg,
                                accessor: $"this.{field.Name}",
                                rhs: $"({field.TypeName(getter: false)})obj",
                                internalUse: false);
                        }
                    }

                    GenerateStandardIndexDefault(fg, LoquiInterfaceType.IGetter, "SetNthObject", "index", false, false, "obj");
                }
            }
            fg.AppendLine();
        }

        protected virtual void GenerateUnsetNthObject(FileGeneration fg, MaskTypeSet maskTypes)
        {
            if (!maskTypes.Applicable(LoquiInterfaceType.ISetter, CommonGenerics.Class)) return;
            using (var args = new FunctionWrapper(fg,
                $"public static void UnsetNthObject"))
            {
                args.Add("ushort index");
                args.Add($"{this.Interface()} obj");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var derivatives = IterateFieldIndices()
                        .Where((f) => f.Field.Derivative).ToList();
                    if (derivatives.Count > 0)
                    {
                        foreach (var item in derivatives)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("throw new ArgumentException($\"Tried to unset at a derivative index {index}\");");
                        }
                    }
                    foreach (var field in this.IterateFields())
                    {
                        if (field.Derivative) continue;

                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            if (field.IntegrateField && field.ReadOnly)
                            {
                                fg.AppendLine("throw new ArgumentException(\"Tried to set at a readonly index \" + index);");
                            }
                            else
                            {
                                field.GenerateUnsetNth(fg, Accessor.FromType(field, "obj"));
                            }
                        }
                    }

                    GenerateStandardIndexDefault(fg, LoquiInterfaceType.ISetter, "UnsetNthObject", "index", false, true, "obj");
                }
            }
            fg.AppendLine();
        }

        private void GenerateNthObjectIsLoqui(FileGeneration fg)
        {
            fg.AppendLine("public static bool GetNthIsLoqui(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    Func<TypeGeneration, bool> tester = (t) =>
                    {
                        if (t is LoquiType)
                        {
                            return true;
                        }
                        else if (t is WrapperType wrapper)
                        {
                            if (wrapper.SubTypeGeneration is LoquiType)
                            {
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                        else
                        {
                            return false;
                        }
                    };

                    var trues = IterateFieldIndices().Where((i) => tester(i.Field));
                    var falses = IterateFieldIndices().Where((i) => !tester(i.Field));
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField || !item.Field.Enabled) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthIsLoqui", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateNthObjectIsDerivative(FileGeneration fg)
        {
            fg.AppendLine("public static bool IsNthDerivative(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var trues = IterateFieldIndices().Where((i) => i.Field.Derivative);
                    var falses = IterateFieldIndices().Where((i) => !i.Field.Derivative);
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField || !item.Field.Enabled) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "IsNthDerivative", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateNthObjectIsEnumerable(FileGeneration fg)
        {
            fg.AppendLine("public static bool GetNthIsEnumerable(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var trues = IterateFieldIndices().Where((i) => i.Field is ContainerType);
                    var falses = IterateFieldIndices().Where((i) => !(i.Field is ContainerType));
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField || !item.Field.Enabled) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthIsEnumerable", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetNthType(FileGeneration fg, bool generic)
        {
            fg.AppendLine($"public{(generic ? " new " : " ")}static Type GetNthType(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField && field.Enabled)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNthType(fg);
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthType", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetNthName(FileGeneration fg)
        {
            fg.AppendLine("public static string GetNthName(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField && field.Enabled)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField && field.Enabled))
                        {
                            field.GenerateGetNthName(fg);
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthName", "index", true);
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetNthIsSingleton(FileGeneration fg)
        {
            fg.AppendLine("public static bool GetNthIsSingleton(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    Func<TypeGeneration, bool> tester = (f) =>
                    {
                        if (!(f is LoquiType loqui)) return false;
                        return loqui.Singleton;
                    };
                    var trues = IterateFieldIndices().Where((i) => tester(i.Field));
                    var falses = IterateFieldIndices().Where((i) => !tester(i.Field));
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField || !item.Field.Enabled) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "GetNthIsSingleton", "index", true);
                }
            }
            fg.AppendLine();
        }

        public void GenerateGetterInterfaceImplementations(FileGeneration fg)
        {
            fg.AppendLine($"void {nameof(IPrintable)}.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);");
            //fg.AppendLine($"IMask<bool> IEqualsMask.GetEqualsMask(object rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask(({this.Interface(getter: true, internalInterface: true)})rhs, include);");
            fg.AppendLine();
        }

        protected virtual async Task GenerateGetEqualsMaskMixIn(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg, $"public static {this.GetMaskString("bool")} GetEqualsMask{this.GetGenericTypes(MaskType.Normal)}"))
            {
                args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.IGetter));
                args.Add($"this {this.Interface(getter: true, internalInterface: true)} item");
                args.Add($"{this.Interface(getter: true, internalInterface: true)} rhs");
                args.Add($"EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return {this.CommonClassInstance("item", LoquiInterfaceType.IGetter, CommonGenerics.Class)}.GetEqualsMask"))
                {
                    args.AddPassArg("item");
                    args.AddPassArg("rhs");
                    args.AddPassArg("include");
                }
            }
            fg.AppendLine();
        }

        private void GenerateGetEqualsMask(FileGeneration fg, MaskTypeSet maskTypes)
        {
            if (!maskTypes.Applicable(LoquiInterfaceType.IGetter, CommonGenerics.Class)) return;
            using (var args = new FunctionWrapper(fg, $"public {this.GetMaskString("bool")} GetEqualsMask"))
            {
                args.Add($"{this.Interface(getter: true, internalInterface: true)} item");
                args.Add($"{this.Interface(getter: true, internalInterface: true)} rhs");
                args.Add($"EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var ret = new {this.GetMaskString("bool")}(false);");
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClassInstance("item", LoquiInterfaceType.IGetter, CommonGenerics.Class)}.FillEqualsMask"))
                {
                    args.AddPassArg("item");
                    args.AddPassArg("rhs");
                    args.AddPassArg("ret");
                    args.AddPassArg("include");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg, $"public void FillEqualsMask"))
            {
                args.Add($"{this.Interface(getter: true, internalInterface: true)} item");
                args.Add($"{this.Interface(getter: true, internalInterface: true)} rhs");
                args.Add($"{this.GetMaskString("bool")} ret");
                args.Add($"EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("if (rhs == null) return;");
                foreach (var field in this.IterateFields())
                {
                    if (!HasKeyField() || field.KeyField)
                    {
                        field.GenerateForEqualsMask(
                            fg,
                            Accessor.FromType(field, $"item"),
                            Accessor.FromType(field, "rhs"),
                            $"ret.{field.Name}");
                    }
                }
                if (this.HasLoquiBaseObject)
                {
                    fg.AppendLine($"base.FillEqualsMask(item, rhs, ret, include);");
                }
            }
            fg.AppendLine();
        }

        public void GenerateStandardRegistrationDefault(FileGeneration fg, string functionName, string indexAccessor, bool ret, params string[] otherParameters)
        {
            fg.AppendLine("default:");
            using (new DepthWrapper(fg))
            {
                if (this.HasLoquiBaseObject)
                {
                    fg.AppendLine($"{(ret ? "return " : string.Empty)}{BaseClass.RegistrationName}.{functionName}({string.Join(", ", indexAccessor.AsEnumerable().And(otherParameters))});");
                    if (!ret)
                    {
                        fg.AppendLine("break;");
                    }
                }
                else
                {
                    GenerateIndexOutOfRangeEx(fg, indexAccessor);
                }
            }
        }

        public void GenerateStandardIndexDefault(
            FileGeneration fg,
            LoquiInterfaceType loquiInterface,
            string functionName,
            string indexAccessor,
            bool ret,
            bool common,
            params string[] otherParameters)
        {
            fg.AppendLine("default:");
            using (new DepthWrapper(fg))
            {
                if (this.HasLoquiBaseObject)
                {
                    if (common)
                    {
                        fg.AppendLine($"{(ret ? "return " : string.Empty)}{BaseClass.CommonClassName(loquiInterface)}.{functionName}{this.BaseGenericTypes}({string.Join(", ", indexAccessor.AsEnumerable().And(otherParameters))});");
                    }
                    else
                    {
                        fg.AppendLine($"{(ret ? "return " : string.Empty)}base.{functionName}({string.Join(", ", indexAccessor.AsEnumerable().And(otherParameters))});");
                    }
                    if (!ret)
                    {
                        fg.AppendLine("break;");
                    }
                }
                else
                {
                    GenerateIndexOutOfRangeEx(fg, indexAccessor);
                }
            }
        }

        public void GenerateIndexOutOfRangeEx(FileGeneration fg, string indexAccessor)
        {
            fg.AppendLine($"throw new ArgumentException($\"Index is out of range: {{{indexAccessor}}}\");");
        }

        private void GenerateGetNameIndex(FileGeneration fg)
        {
            fg.AppendLine("public static ushort? GetNameIndex(StringCaseAgnostic str)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine("switch (str.Upper)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.IntegrateField)
                        {
                            if (string.IsNullOrWhiteSpace(field.Name)) return;
                            fg.AppendLine($"case \"{field.Name.ToUpper()}\":");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateGetNameIndex(fg);
                        }
                    }

                    fg.AppendLine("default:");
                    using (new DepthWrapper(fg))
                    {
                        fg.AppendLine("return null;");
                    }
                }
            }
            fg.AppendLine();
        }

        private async Task AddNamespaces(FileGeneration fg)
        {
            RequiredNamespaces.Add(
                await this.gen.GenerationModules.ToAsyncEnumerable()
                    .SelectMany((tr) => tr.RequiredUsingStatements(this))
                    .ToListAsync());
            RequiredNamespaces.Add(
                (await Task.WhenAll(this.GenerationInterfaces.Select((tr) => tr.RequiredUsingStatements())))
                    .SelectMany(i => i));
            using (new RegionWrapper(fg, "Usings"))
            {
                foreach (var nameSpace in RequiredNamespaces.Union(gen.Namespaces).OrderBy(x => x))
                {
                    fg.AppendLine($"using {nameSpace};");
                }
            }
        }

        public void GenerateEqualsSection(FileGeneration fg)
        {
            // Generate equals and hash
            if (GenerateEquals)
            {
                using (new RegionWrapper(fg, "Equals and Hash"))
                {
                    fg.AppendLine("public override bool Equals(object? obj)");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"if (!(obj is {this.Interface(getter: true, internalInterface: true)} rhs)) return false;");
                        fg.AppendLine($"return {this.CommonClassInstance("this", LoquiInterfaceType.IGetter, CommonGenerics.Class)}.Equals(this, rhs);");
                    }
                    fg.AppendLine();

                    fg.AppendLine($"public bool Equals({this.Interface(getter: true, internalInterface: true)}? obj)");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"return {this.CommonClassInstance("this", LoquiInterfaceType.IGetter, CommonGenerics.Class)}.Equals(this, obj);");
                    }
                    fg.AppendLine();

                    fg.AppendLine($"public override int GetHashCode() => {this.CommonClassInstance("this", LoquiInterfaceType.IGetter, CommonGenerics.Class)}.GetHashCode(this);");
                    fg.AppendLine();
                }
            }
        }

        private async Task GenerateEqualsMixIn(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static bool Equals{this.GetGenericTypes(MaskType.Normal)}"))
            {
                args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.IGetter));
                args.Add($"this {this.Interface(getter: true, internalInterface: true)} item");
                args.Add($"{this.Interface(getter: true, internalInterface: true)} rhs");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return {this.CommonClassInstance("item", LoquiInterfaceType.IGetter, CommonGenerics.Class)}.Equals"))
                {
                    args.Add("lhs: item");
                    args.Add("rhs: rhs");
                }
            }
            fg.AppendLine();
        }

        private void GenerateEqualsCommon(FileGeneration fg, MaskTypeSet maskTypes)
        {
            if (!maskTypes.Applicable(LoquiInterfaceType.IGetter, CommonGenerics.Class)) return;
            using (new RegionWrapper(fg, "Equals and Hash"))
            {
                using (var args = new FunctionWrapper(fg, $"public virtual bool Equals"))
                {
                    args.Add($"{this.Interface(getter: true, internalInterface: true)}? lhs");
                    args.Add($"{this.Interface(getter: true, internalInterface: true)}? rhs");
                }
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine("if (lhs == null && rhs == null) return false;");
                    fg.AppendLine("if (lhs == null || rhs == null) return false;");
                    if (this.HasLoquiBaseObject)
                    {
                        fg.AppendLine($"if (!base.Equals(({this.BaseClass.Interface(getter: true, internalInterface: true)})lhs, ({this.BaseClass.Interface(getter: true, internalInterface: true)})rhs)) return false;");
                    }
                    foreach (var field in this.IterateFields())
                    {
                        if (!HasKeyField() || field.KeyField)
                        {
                            var lhsAccessor = Accessor.FromType(field, "lhs");
                            var rhsAccessor = Accessor.FromType(field, "rhs");
                            if (field.IntegrateField)
                            {
                                field.GenerateForEquals(fg, lhsAccessor, rhsAccessor);
                            }
                            else
                            {
                                field.GenerateForEquals(fg, lhsAccessor, rhsAccessor);
                            }
                        }
                    }
                    fg.AppendLine("return true;");
                }
                fg.AppendLine();

                foreach (var baseObj in this.BaseClassTrail())
                {
                    using (var args = new FunctionWrapper(fg,
                        $"public override bool Equals"))
                    {
                        args.Add($"{baseObj.Interface(getter: true, internalInterface: true)}? lhs");
                        args.Add($"{baseObj.Interface(getter: true, internalInterface: true)}? rhs");
                    }
                    using (new BraceWrapper(fg))
                    {
                        using (var args = new ArgsWrapper(fg,
                            "return Equals"))
                        {
                            args.Add($"lhs: ({this.Interface(getter: true, internalInterface: true)}?)lhs");
                            args.Add($"rhs: rhs as {this.Interface(getter: true, internalInterface: true)}");
                        }
                    }
                    fg.AppendLine();
                }

                using (var args = new FunctionWrapper(fg, $"public virtual int GetHashCode"))
                {
                    args.Add($"{this.Interface(getter: true, internalInterface: true)} item");
                }
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine("var hash = new HashCode();");
                    foreach (var field in this.IterateFields())
                    {
                        var itemAccessor = Accessor.FromType(field, "item");
                        if (!HasKeyField() || field.KeyField)
                        {
                            field.GenerateForHash(fg, itemAccessor, "hash");
                        }
                    }
                    if (this.HasLoquiBaseObject)
                    {
                        fg.AppendLine($"hash.Add(base.GetHashCode());");
                    }
                    fg.AppendLine("return hash.ToHashCode();");
                }
                fg.AppendLine();

                foreach (var baseObj in this.BaseClassTrail())
                {
                    using (var args = new FunctionWrapper(fg,
                        $"public override int GetHashCode"))
                    {
                        args.Add($"{baseObj.Interface(getter: true, internalInterface: true)} item");
                    }
                    using (new BraceWrapper(fg))
                    {
                        using (var args = new ArgsWrapper(fg,
                            "return GetHashCode"))
                        {
                            args.Add($"item: ({this.Interface(getter: true, internalInterface: true)})item");
                        }
                    }
                    fg.AppendLine();
                }
            }
            fg.AppendLine();
        }

        public bool SupportsCopy()
        {
            return true;
        }

        private async Task GenerateCreateNew(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"internal static{this.NewOverride()}{this.ObjectName} GetNew"))
            {
            }
            using (new BraceWrapper(fg))
            {
                if (this.Abstract)
                {
                    fg.AppendLine($"throw new ArgumentException(\"New called on an abstract class.\");");
                }
                else
                {
                    fg.AppendLine($"return new {this.ObjectName}();");
                }
            }
            fg.AppendLine();
        }

        private async Task GenerateCreateNewBasicCommon(FileGeneration fg, MaskTypeSet maskTypes)
        {
            if (!maskTypes.Applicable(LoquiInterfaceType.IGetter, CommonGenerics.Class)) return;
            using (var args = new FunctionWrapper(fg,
                $"public{this.FunctionOverride()}object GetNew{this.GetGenericTypesNickname("_Setter", MaskType.Normal)}"))
            {
                args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.ISetter, nickname: "_Setter"));
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"return {this.Name}{this.GetGenericTypesNickname("_Setter", MaskType.Normal)}.GetNew();");
            }
            fg.AppendLine();
        }

        public async Task GenerateToStringCode(FileGeneration fg)
        {
            using (new RegionWrapper(fg, "To String"))
            {
                if (GenerateToString)
                {
                    fg.AppendLine($"public override string ToString()");
                    using (new BraceWrapper(fg))
                    {
                        using (var args = new ArgsWrapper(fg,
                            $"return {this.MixInClassName}.ToString"))
                        {
                            args.Add("item: this");
                        }
                    }
                    fg.AppendLine();
                }
                fg.AppendLine();

                using (var args = new FunctionWrapper(fg,
                    $"public{this.FunctionOverride()}void ToString"))
                {
                    args.Add($"FileGeneration fg");
                    args.Add($"string? name = null");
                }
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        $"{this.MixInClassName}.ToString"))
                    {
                        args.Add("item: this");
                        args.AddPassArg("name");
                    }
                }
                fg.AppendLine();
            }
        }

        private async Task GenerateModules(FileGeneration fg)
        {
            foreach (var transl in gen.GenerationModules)
            {
                using (new RegionWrapper(fg, transl.RegionString))
                {
                    await transl.GenerateInClass(this, fg);
                    if (!this.IsGeneric)
                    {
                        await transl.GenerateInNonGenericClass(this, fg);
                    }
                }
            }
        }

        private void GenerateInterfacesInClass(FileGeneration fg)
        {
            if (this.GenerationInterfaces.Count > 0)
            {
                foreach (var interf in gen.GenerationInterfaces)
                {
                    using (new RegionWrapper(fg, interf.RegionString))
                    {
                        interf.GenerateInClass(this, fg);
                    }
                }
            }
        }

        public virtual void GenerateCopy(FileGeneration fg, MaskTypeSet maskTypeSet)
        {
            if (!maskTypeSet.Applicable(LoquiInterfaceType.ISetter, CommonGenerics.Class)) return;
            if (!SupportsCopy()) return;
            using (var args = new FunctionWrapper(fg,
                $"public{this.NewOverride(o => o.SupportsCopy())}{this.ObjectName} Copy{this.GetGenericTypes(MaskType.Copy)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, maskTypes: MaskType.Copy));
                args.Add($"{this.ObjectName} item");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                if (this.Abstract)
                {
                    fg.AppendLine($"{this.ObjectName} ret = ({this.ObjectName})System.Activator.CreateInstance(item.GetType());");
                }
                else
                {
                    fg.AppendLine($"{this.ObjectName} ret = GetNew();");
                }
                using (var args = new ArgsWrapper(fg,
                    $"ret.CopyIn{this.GetGenericTypes(MaskType.Normal, MaskType.Copy)}"))
                {
                    args.Add("item");
                    args.Add("copyMask: copyMask");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();
        }

        public void GenerateCopyMixIn(FileGeneration fg)
        {
            if (!SupportsCopy()) return;
            using (var args = new FunctionWrapper(fg,
                $"public static {this.ObjectName} Copy{this.GetGenericTypes(MaskType.Normal, MaskType.Copy)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.Copy));
                args.Add($"this {this.ObjectName} item");
                args.Add($"{this.Mask(MaskType.Copy)} copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return {this.CommonClassInstance("item", LoquiInterfaceType.ISetter, CommonGenerics.Class)}.Copy"))
                {
                    args.AddPassArg("item");
                    args.AddPassArg("copyMask");
                }
            }
            fg.AppendLine();
        }

        public virtual void GenerateDeepCopy(FileGeneration fg, MaskTypeSet maskTypeSet)
        {
            if (!maskTypeSet.Applicable(LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Normal, MaskType.Translation)) return;
            if (!SupportsCopy()) return;
            using (var args = new FunctionWrapper(fg,
                $"public {this.ObjectName} DeepCopy{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter, MaskType.Translation)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter, MaskType.Translation));
                args.Add($"{this.Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} item");
                args.Add($"{this.Mask(MaskType.Translation)}? copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.ObjectName} ret = ({this.ObjectName}){this.CommonClassInstance("item", LoquiInterfaceType.IGetter, CommonGenerics.Class, MaskType.NormalGetter)}.GetNew{this.GetGenericTypes(MaskType.Normal)}();");
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClassInstance("ret", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Translation)}.DeepCopyIn{GenerateGenericClause(GenericTypes_Nickname(MaskType.Normal), GenericTypes_Nickname(MaskType.NormalGetter))}"))
                {
                    args.Add("item: ret");
                    args.Add("rhs: item");
                    args.Add("errorMask: null");
                    args.Add($"copyMask: copyMask?.GetCrystal()");
                    args.Add($"deepCopy: true");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public {this.ObjectName} DeepCopy{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter, MaskType.Error, MaskType.Translation)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter, MaskType.Error, MaskType.Translation));
                args.Add($"{this.Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} item");
                args.Add($"out {this.Mask(MaskType.Error)} errorMask");
                args.Add($"{this.Mask(MaskType.Translation)}? copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"var errorMaskBuilder = new ErrorMaskBuilder();");
                fg.AppendLine($"{this.ObjectName} ret = ({this.ObjectName}){this.CommonClassInstance("item", LoquiInterfaceType.IGetter, CommonGenerics.Class, MaskType.NormalGetter)}.GetNew{this.GetGenericTypes(MaskType.Normal)}();");
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClassInstance("ret", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Translation)}.DeepCopyIn{GenerateGenericClause(GenericTypes_Nickname(MaskType.Normal), GenericTypes_Nickname(MaskType.NormalGetter))}"))
                {
                    args.Add("ret");
                    args.Add("item");
                    args.Add("errorMask: errorMaskBuilder");
                    args.Add("copyMask: copyMask?.GetCrystal()");
                    args.Add("deepCopy: true");
                }
                fg.AppendLine($"errorMask = {this.Mask(MaskType.Error)}.Factory(errorMaskBuilder);");
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public {this.ObjectName} DeepCopy{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter));
                args.Add($"{this.Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} item");
                args.Add($"ErrorMaskBuilder? errorMask");
                args.Add($"TranslationCrystal? copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.ObjectName} ret = ({this.ObjectName}){this.CommonClassInstance("item", LoquiInterfaceType.IGetter, CommonGenerics.Class, MaskType.NormalGetter)}.GetNew{this.GetGenericTypes(MaskType.Normal)}();");
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClassInstance("ret", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.Translation)}.DeepCopyIn{GenerateGenericClause(GenericTypes_Nickname(MaskType.Normal), GenericTypes_Nickname(MaskType.NormalGetter))}"))
                {
                    args.Add("item: ret");
                    args.Add("rhs: item");
                    args.AddPassArg("errorMask");
                    args.AddPassArg("copyMask");
                    args.Add($"deepCopy: true");
                }
                fg.AppendLine("return ret;");
            }
            fg.AppendLine();
        }

        public void GenerateDeepCopyMixIn(FileGeneration fg)
        {
            if (!SupportsCopy()) return;
            using (var args = new FunctionWrapper(fg,
                $"public static {this.ObjectName} DeepCopy{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter, MaskType.Translation)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter, MaskType.Translation));
                args.Add($"this {this.Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} item");
                args.Add($"{this.Mask(MaskType.Translation)}? copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return {this.CommonClassInstance("item", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.NormalGetter, MaskType.Translation)}.DeepCopy{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter, MaskType.Translation)}"))
                {
                    args.AddPassArg("item");
                    args.AddPassArg("copyMask");
                }
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static {this.ObjectName} DeepCopy{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter, MaskType.Error, MaskType.Translation)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter, MaskType.Error, MaskType.Translation));
                args.Add($"this {this.Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} item");
                args.Add($"out {this.Mask(MaskType.Error)} errorMask");
                args.Add($"{this.Mask(MaskType.Translation)}? copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return {this.CommonClassInstance("item", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.NormalGetter, MaskType.Translation)}.DeepCopy{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter, MaskType.Error, MaskType.Translation)}"))
                {
                    args.AddPassArg("item");
                    args.AddPassArg("copyMask");
                    args.Add("errorMask: out errorMask");
                }
            }
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public static {this.ObjectName} DeepCopy{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter)}"))
            {
                args.Wheres.AddRange(this.GenericTypeMaskWheres(LoquiInterfaceType.ISetter, MaskType.Normal, MaskType.NormalGetter));
                args.Add($"this {this.Interface(this.GetGenericTypes(MaskType.NormalGetter), getter: true, internalInterface: true)} item");
                args.Add($"ErrorMaskBuilder? errorMask");
                args.Add($"TranslationCrystal? copyMask = null");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"return {this.CommonClassInstance("item", LoquiInterfaceType.ISetter, CommonGenerics.Functions, MaskType.NormalGetter, MaskType.Translation)}.DeepCopy{this.GetGenericTypes(MaskType.Normal, MaskType.NormalGetter)}"))
                {
                    args.AddPassArg("item");
                    args.AddPassArg("copyMask");
                    args.AddPassArg("errorMask");
                }
            }
            fg.AppendLine();
        }

        protected virtual async Task GenerateClearMixIn(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"public static void Clear{this.GetGenericTypes(MaskType.Normal)}"))
            {
                args.Wheres.AddRange(GenerateWhereClauses(LoquiInterfaceType.ISetter));
                args.Add($"this {this.Interface(internalInterface: true)} item");
            }
            using (new BraceWrapper(fg))
            {
                using (var args = new ArgsWrapper(fg,
                    $"{this.CommonClassInstance("item", LoquiInterfaceType.ISetter, CommonGenerics.Class)}.Clear"))
                {
                    args.AddPassArg("item");
                }
            }
            fg.AppendLine();
        }

        protected void GenerateClear(FileGeneration fg)
        {
            using (var args = new FunctionWrapper(fg,
                $"void {nameof(IClearable)}.Clear"))
            {
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.CommonClassInstance("this", LoquiInterfaceType.ISetter, CommonGenerics.Class)}.Clear(this);");
            }
            fg.AppendLine();
        }

        protected virtual async Task GenerateClearCommon(FileGeneration fg, MaskTypeSet maskTypes)
        {
            if (!maskTypes.Applicable(LoquiInterfaceType.ISetter, CommonGenerics.Class)) return;
            fg.AppendLine("partial void ClearPartial();");
            fg.AppendLine();

            using (var args = new FunctionWrapper(fg,
                $"public{this.Virtual()}void Clear"))
            {
                args.Add($"{this.Interface(internalInterface: true)} item");
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"ClearPartial();");
                foreach (var field in this.IterateFields())
                {
                    if (field.ReadOnly) continue;
                    if (field.CustomClear)
                    {
                        fg.AppendLine($"{field.Name}CustomClear(item);");
                    }
                    else
                    {
                        field.GenerateClear(fg, Accessor.FromType(field, "item"));
                    }
                }
                if (this.HasLoquiBaseObject)
                {
                    fg.AppendLine($"base.Clear(item);");
                }
            }
            fg.AppendLine();

            foreach (var baseObj in this.BaseClassTrail())
            {
                using (var args = new FunctionWrapper(fg,
                    $"public override void Clear"))
                {
                    args.Add($"{baseObj.Interface(internalInterface: true)} item");
                }
                using (new BraceWrapper(fg))
                {
                    using (var args = new ArgsWrapper(fg,
                        "Clear"))
                    {
                        args.Add($"item: ({this.Interface(internalInterface: true)})item");
                    }
                }
                fg.AppendLine();
            }

            foreach (var field in this.Fields)
            {
                if (!field.CustomClear) continue;
                using (var args = new ArgsWrapper(fg,
                    $"void {field.Name}CustomClear"))
                {
                    args.Add($"{this.Interface(internalInterface: true)} item");
                }
            }
        }

        protected virtual void GenerateGenericCreate(FileGeneration fg)
        {
            if (!this.Abstract)
            {
                fg.AppendLine($"public{this.NewOverride()}static {this.ObjectName} {Loqui.Internal.Constants.CREATE_FUNC_NAME}(IEnumerable<KeyValuePair<ushort, object>> fields)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine($"var ret = new {this.ObjectName}();");
                    fg.AppendLine($"foreach (var pair in fields)");
                    using (new BraceWrapper(fg))
                    {
                        fg.AppendLine($"CopyInInternal_{this.Name}(ret, pair);");
                    }
                    fg.AppendLine("return ret;");
                }
                fg.AppendLine();
            }

            fg.AppendLine($"protected{this.NewOverride()}static void CopyInInternal_{this.Name}({this.ObjectName} obj, KeyValuePair<ushort, object> pair)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"if (!EnumExt.TryParse(pair.Key, out {this.FieldIndexName} enu))");
                using (new BraceWrapper(fg))
                {
                    if (this.HasLoquiBaseObject)
                    {
                        fg.AppendLine($"CopyInInternal_{this.BaseClass.Name}(obj, pair);");
                    }
                    else
                    {
                        fg.AppendLine("throw new ArgumentException($\"Unknown index: {pair.Key}\");");
                    }
                }
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    foreach (var field in this.IterateFields())
                    {
                        if (field.Derivative) continue;
                        if (field.IntegrateField)
                        {
                            fg.AppendLine($"case {field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg, doIt: field.IntegrateField))
                        {
                            field.GenerateSetNth(
                                fg,
                                accessor: $"obj.{field.Name}",
                                rhs: $"({field.TypeName(getter: false)})pair.Value",
                                internalUse: true);
                        }
                    }
                    fg.AppendLine("default:");
                    using (new DepthWrapper(fg))
                    {
                        fg.AppendLine("throw new ArgumentException($\"Unknown enum type: {enu}\");");
                    }
                }
            }

            if (this.GenerateNthReflections)
            {
                fg.AppendLine($"public static void {Loqui.Internal.Constants.COPYIN_FUNC_NAME}(IEnumerable<KeyValuePair<ushort, object>> fields, {this.ObjectName} obj)");
                using (new BraceWrapper(fg))
                {
                    fg.AppendLine("ILoquiObjectExt.CopyFieldsIn(obj, fields, skipProtected: false);");
                }
                fg.AppendLine();
            }
        }

        private void GenerateIsProtected(FileGeneration fg)
        {
            fg.AppendLine("public static bool IsProtected(ushort index)");
            using (new BraceWrapper(fg))
            {
                fg.AppendLine($"{this.FieldIndexName} enu = ({this.FieldIndexName})index;");
                fg.AppendLine("switch (enu)");
                using (new BraceWrapper(fg))
                {
                    var trues = IterateFieldIndices().Where((i) => i.Field.ReadOnly);
                    var falses = IterateFieldIndices().Where((i) => !i.Field.ReadOnly);
                    if (trues.Any())
                    {
                        foreach (var item in trues)
                        {
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return true;");
                        }
                    }
                    if (falses.Any())
                    {
                        foreach (var item in falses)
                        {
                            if (!item.Field.IntegrateField || !item.Field.Enabled) continue;
                            fg.AppendLine($"case {item.Field.IndexEnumName}:");
                        }
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine("return false;");
                        }
                    }

                    GenerateStandardRegistrationDefault(fg, "IsProtected", "index", true);
                }
            }
            fg.AppendLine();
        }
        #endregion

        private async Task GenerateTranslations(FileGeneration fg)
        {
            if (this.gen.GenerationModules.Count == 0) return;
            using (new RegionWrapper(fg, "Modules"))
            {
                foreach (var translGen in this.gen.GenerationModules)
                {
                    using (new RegionWrapper(fg, translGen.RegionString))
                    {
                        await translGen.GenerateInVoid(this, fg);
                    }
                }
            }

            await Task.WhenAll(this.gen.GenerationModules
                .Select((g) => g.MiscellaneousGenerationActions(this)));
        }

        private async Task GenerateNonGenericClass(FileGeneration fg)
        {
            if (!this.IsGeneric) return;
            FileGeneration subGen = new FileGeneration();
            foreach (var translGen in this.gen.GenerationModules)
            {
                using (new RegionWrapper(fg, translGen.RegionString))
                {
                    await translGen.GenerateInNonGenericClass(this, subGen);
                }
            }

            if (subGen.Count == 0) return;

            using var ns = new NamespaceWrapper(fg, this.Namespace);
            using (var args = new ClassWrapper(fg, this.Name))
            {
                args.Static = true;
            }
            using (new BraceWrapper(fg))
            {
                fg.AppendLines(subGen);
            }
        }

        private void GenerateLoquiInterfaces(FileGeneration fg)
        {
            if (this.gen.GenerationModules.Count == 0) return;
            using (new RegionWrapper(fg, "Loqui Interfaces"))
            {
                foreach (var interfGen in this.GenerationInterfaces)
                {
                    using (new RegionWrapper(fg, interfGen.RegionString))
                    {
                        interfGen.Generate(this, fg);
                    }
                }
            }
        }

        public bool HasLoquiInterface<T>()
            where T : GenerationInterface
        {
            return this.GenerationInterfaces.Any((i) => i.GetType().Equals(typeof(T)));
        }

        public string GetMaskString(string t, bool addClassName = true)
        {
            if (t.Equals("Exception"))
            {
                return this.Mask(MaskType.Error);
            }
            else
            {
                return $"{(addClassName ? $"{this.Name}." : null)}Mask<{t}>";
            }
        }

        public virtual async Task Resolve()
        {
            foreach (var gen in this.Generics.Values)
            {
                gen.Resolve(this);
            }

            await Task.WhenAll(this.IterateFields().ToList().Select((f) => f.Resolve()));

            if (this.HasLoquiBaseObject)
            {
                AddBaseClassNamespaces(this);

                foreach (var baseGen in this.BaseClass.Generics)
                {
                    if (this.Generics.TryGetValue(baseGen.Key, out var existing))
                    {
                        if (!existing.Override)
                        {
                            throw new ArgumentException("Generic added with the same name that was not marked as override.");
                        }
                    }
                    else
                    {
                        this.Generics.Add(baseGen.Key, baseGen.Value.Copy());
                    }
                    this.BaseGenerics[baseGen.Key] = baseGen.Key;
                }

                foreach (var baseGeneric in Node.Elements(XName.Get("BaseGeneric", LoquiGenerator.Namespace)))
                {
                    var genName = baseGeneric.GetAttribute("name");
                    var whereElem = baseGeneric.Elements(XName.Get("Where", LoquiGenerator.Namespace)).ToArray();
                    var definedElem = baseGeneric.Element(XName.Get("Defined", LoquiGenerator.Namespace));
                    if (whereElem.Any()
                        && definedElem != null)
                    {
                        throw new ArgumentException("Cannot define both Where and Defined nodes.");
                    }
                    if (whereElem.Any())
                    {
                        this.BaseGenerics[genName] = genName;
                        this.Generics[genName].Add(whereElem.Select((w) => w.Value));
                    }
                    else if (definedElem != null)
                    {
                        this.BaseGenerics[genName] = definedElem.Value;
                        this.Generics.Remove(genName);
                    }
                    else
                    {
                        throw new ArgumentException("Need to define Where or Defined node.");
                    }
                }
            }

            await Task.WhenAll(this.gen.GenerationModules.Select((mod) => mod.Resolve(this)));

            await Task.WhenAll(this.Interfaces.Select((interf) => interf.Resolve(this)));
        }

        private void AddBaseClassNamespaces(ObjectGeneration obj)
        {
            if (!obj.HasLoquiBaseObject) return;
            this.RequiredNamespaces.Add(obj.BaseClass.Namespace);
            this.RequiredNamespaces.Add(obj.BaseClass.InternalNamespace);
            AddBaseClassNamespaces(obj.BaseClass);
        }

        public void RegenerateAndStampSourceXML()
        {
            XDocument doc;
            using (var stream = new FileStream(this.SourceXMLFile.FullName, FileMode.Open))
            {
                doc = XDocument.Load(stream);
            }
            bool modified = false;

            var LoquiNode = doc.Element(XName.Get("Loqui", LoquiGenerator.Namespace));
            foreach (var obj in LoquiNode.Elements(XName.Get("Object", LoquiGenerator.Namespace))
                .And(LoquiNode.Elements(XName.Get("Struct", LoquiGenerator.Namespace))))
            {
                var name = obj.GetAttribute("name");
                if (name.Equals(this.Name))
                {
                    if (obj.GetAttribute("GUID") == null)
                    {
                        var guidAttr = new XAttribute("GUID", this.GUID.ToString());
                        obj.Add(guidAttr);
                        modified = true;
                    }
                    if (obj.GetAttribute("ID") == null)
                    {
                        var guidAttr = new XAttribute("ID", this.ID.ToString());
                        obj.Add(guidAttr);
                        modified = true;
                    }
                    break;
                }
            }

            if (!modified) return;

            using (var xmlWriter = new XmlTextWriter(new FileStream(this.SourceXMLFile.FullName, FileMode.Create), Encoding.ASCII))
            {
                xmlWriter.Formatting = Formatting.Indented;
                xmlWriter.Indentation = 2;
                doc.WriteTo(xmlWriter);
            }
            using var streamWriter = File.AppendText(this.SourceXMLFile.FullName);
            streamWriter.Write(Environment.NewLine);
        }

        public string Mask_Specified(MaskType type, GenericSpecification specifications, bool addClassName = true)
        {
            return $"{(addClassName ? $"{this.Name}." : null)}{this.Mask_BasicName(type)}{GenerateGenericClause(GenericTypes_Nickname(type, specifications.Specifications.ToArray()))}";
        }

        public string MaskNickname(string name, MaskType maskType)
        {
            switch (maskType)
            {
                case MaskType.Normal:
                    return name;
                case MaskType.NormalGetter:
                    return $"{name}Getter";
                case MaskType.Error:
                    return $"{name}_{MaskModule.ErrMaskNickname}";
                case MaskType.Copy:
                    return $"{name}_{MaskModule.CopyMaskNickname}";
                case MaskType.Translation:
                    return $"{name}_{MaskModule.TranslationMaskNickname}";
                default:
                    throw new NotImplementedException();
            }
        }

        public string SpecifyGeneric(MaskType maskType, KeyValuePair<string, GenericDefinition> g, params KeyValuePair<string, string>[] specifications)
        {
            var specification = specifications.FirstOrDefault((spec) => spec.Key == g.Key);
            if (specification.Value == null)
            {
                return MaskNickname(g.Key, maskType);
            }
            else
            {
                var nameKey = ObjectNamedKey.Factory(specification.Value, this.ProtoGen.Protocol);
                if (!this.ProtoGen.Gen.ObjectGenerationsByObjectNameKey.TryGetValue(
                   nameKey,
                   out var targetObj))
                {
                    throw new ArgumentException($"{nameKey} can not be located.");
                }
                return targetObj.Mask(maskType);
            }
        }

        public IEnumerable<string> GenericTypes_Nickname(MaskType maskType, params KeyValuePair<string, string>[] specifications)
        {
            return Generics
                .Where(g => g.Value.Loqui)
                .Select((g) =>
                {
                    return SpecifyGeneric(maskType, g, specifications);
                });
        }

        public IEnumerable<string> BaseGenericTypes_Nickname(MaskType maskType, params KeyValuePair<string, string>[] specifications)
        {
            return Generics
                .Where((g) => g.Value.BaseObjectGeneration != null)
                .Where((g) => this.BaseGenerics.ContainsKey(g.Key))
                .Select((g) =>
                {
                    return SpecifyGeneric(maskType, g, specifications);
                });
        }

        public string Mask_BasicName(MaskType type)
        {
            switch (type)
            {
                case MaskType.Normal:
                    return $"Mask";
                case MaskType.Error:
                    return $"ErrorMask";
                case MaskType.Copy:
                    return $"CopyMask";
                case MaskType.Translation:
                    return $"TranslationMask";
                default:
                    throw new NotImplementedException();
            }
        }

        public string Mask(MaskType type, bool addClassName = true)
        {
            switch (type)
            {
                case MaskType.Error:
                    return $"{(addClassName ? $"{this.Name}." : null)}{this.Mask_BasicName(MaskType.Error)}{GetGenericTypes(MaskType.Error)}";
                case MaskType.Copy:
                    return $"{(addClassName ? $"{this.Name}." : null)}{this.Mask_BasicName(MaskType.Copy)}{GetGenericTypes(MaskType.Copy)}";
                case MaskType.Translation:
                    return $"{(addClassName ? $"{this.Name}." : null)}{this.Mask_BasicName(MaskType.Translation)}{GetGenericTypes(MaskType.Translation)}";
                case MaskType.Normal:
                default:
                    throw new NotImplementedException();
            }
        }

        public bool CanAssume()
        {
            return !Generics.Any(g => g.Value.Loqui && g.Value.BaseObjectGeneration == null);
        }

        public IEnumerable<string> GenericTypes_Assumed(MaskType type, bool onlyAssumeSubclass = false)
        {
            return Generics
                .Where(g => g.Value.Loqui)
                .Select((g) =>
                {
                    if (g.Value.BaseObjectGeneration != null)
                    {
                        if (!onlyAssumeSubclass || !this.BaseGenerics.ContainsKey(g.Key))
                        {
                            return g.Value.BaseObjectGeneration.Mask(type);
                        }
                        else
                        {
                            return SpecifyGeneric(type, g);
                        }
                    }
                    else
                    {
                        switch (type)
                        {
                            case MaskType.Error:
                                return nameof(ErrorMaskPlaceholder);
                            case MaskType.Copy:
                            case MaskType.Normal:
                            default:
                                throw new NotImplementedException();
                        }
                    }
                });
        }

        public string GenericClause_Assumed(MaskType type, bool onlyAssumeSubclass = false)
        {
            return GenerateGenericClause(GenericTypes_Assumed(type, onlyAssumeSubclass));
        }

        public string Mask_GenericAssumed(MaskType type, bool onlyAssumeSubclass = false)
        {
            return $"{this.Mask_BasicName(type)}{GenericClause_Assumed(type, onlyAssumeSubclass)}";
        }

        public string Mask_Unspecified(MaskType type)
        {
            return $"{this.Name}.{this.Mask_BasicName(type)}{GenerateGenericClause(Generics.Where((g) => g.Value.BaseObjectGeneration != null || g.Value.Loqui).Select((g) => string.Empty))}";
        }

        public string BaseMask_GenericClausesAssumed(MaskType type)
        {
            return GenerateGenericClause(Generics.SelectWhere((g) =>
            {
                if (g.Value.BaseObjectGeneration != null)
                {
                    return TryGet<string>.Succeed(g.Value.BaseObjectGeneration.Mask(type));
                }
                else if (g.Value.Loqui)
                {
                    return TryGet<string>.Succeed("IErrorMask");
                }
                else
                {
                    return TryGet<string>.Failure;
                }
            }));
        }

        public string GetBaseMask_GenericTypes(MaskType type)
        {
            if (!this.HasLoquiBaseObject)
            {
                return GetGenericTypes(type);
            }
            return GenerateGenericClause(Generics
                .Where((g) => g.Value.Loqui)
                .Where((g) => this.BaseGenerics.ContainsKey(g.Key))
                .Select((g) =>
                {
                    return SpecifyGeneric(type, g);
                }));
        }

        public IEnumerable<TypeGeneration> IterateFields(
            bool nonIntegrated = false,
            SetMarkerType.ExpandSets expandSets = SetMarkerType.ExpandSets.True,
            bool includeBaseClass = false)
        {
            return IterateFieldIndices(
                nonIntegrated: nonIntegrated,
                expandSets: expandSets,
                includeBaseClass: includeBaseClass).Select((f) => f.Field);
        }

        public IEnumerable<(int PublicIndex, int InternalIndex, TypeGeneration Field)> IterateFieldIndices(
            bool nonIntegrated = false,
            SetMarkerType.ExpandSets expandSets = SetMarkerType.ExpandSets.True,
            bool includeBaseClass = false)
        {
            if (includeBaseClass && this.HasLoquiBaseObject)
            {
                foreach (var item in this.BaseClass.IterateFieldIndices(
                    nonIntegrated: nonIntegrated,
                    expandSets: expandSets,
                    includeBaseClass: includeBaseClass))
                {
                    yield return item;
                }
            }
            int i = this.StartingIndex;
            int index = -1;
            for (int j = 0; j < this.Fields.Count; j++)
            {
                index++;
                var field = this.Fields[j];
                if (!field.Enabled) continue;
                if (!field.IntegrateField)
                {
                    if (field is SetMarkerType set)
                    {
                        switch (expandSets)
                        {
                            case SetMarkerType.ExpandSets.False:
                                continue;
                            case SetMarkerType.ExpandSets.FalseAndInclude:
                                yield return (-1, j, field);
                                continue;
                            case SetMarkerType.ExpandSets.True:
                            case SetMarkerType.ExpandSets.TrueAndInclude:
                                int k = 0;
                                foreach (var subField in set.IterateFields(
                                    nonIntegrated: nonIntegrated,
                                    expandSets: expandSets))
                                {
                                    yield return (subField.Index + i, j, subField.Field);
                                    k++;
                                }
                                i += k;
                                break;
                            default:
                                throw new NotImplementedException();
                        }
                        if (expandSets == SetMarkerType.ExpandSets.TrueAndInclude)
                        {
                            yield return (-1, index, field);
                        }
                    }
                    else if (nonIntegrated)
                    {
                        yield return (-1, index, field);
                    }
                }
                else
                {
                    yield return (i++, index, field);
                }
            }
        }

        public virtual async Task<OverrideType> GetFunctionOverrideType(Func<ClassGeneration, Task<bool>> tester)
        {
            return OverrideType.None;
        }

        public virtual OverrideType GetFunctionOverrideType()
        {
            return OverrideType.None;
        }

        public async Task<string> FunctionOverride(Func<ClassGeneration, Task<bool>> tester, bool prependSpace = true)
        {
            switch (await GetFunctionOverrideType(tester))
            {
                case OverrideType.None:
                    return prependSpace ? " " : string.Empty;
                case OverrideType.HasBase:
                    return $"{(prependSpace ? " " : null)}override ";
                case OverrideType.OnlyHasDerivative:
                    return $"{(prependSpace ? " " : null)}virtual ";
                default:
                    throw new NotImplementedException();
            }
        }

        public string FunctionOverride(bool doIt = true, bool prependSpace = true)
        {
            if (!doIt) return " ";
            switch (GetFunctionOverrideType())
            {
                case OverrideType.None:
                    return prependSpace ? " " : string.Empty;
                case OverrideType.HasBase:
                    return $"{(prependSpace ? " " : null)}override ";
                case OverrideType.OnlyHasDerivative:
                    return $"{(prependSpace ? " " : null)}virtual ";
                default:
                    throw new NotImplementedException();
            }
        }

        public virtual string Virtual(bool doIt = true)
        {
            return " ";
        }

        public IEnumerable<ClassGeneration> BaseClassTrail()
        {
            if (!this.HasLoquiBaseObject) yield break;
            yield return this.BaseClass;
            foreach (var ret in this.BaseClass.BaseClassTrail())
            {
                yield return ret;
            }
        }

        public async Task<IEnumerable<ObjectGeneration>> EntireClassTree()
        {
            var processedObjs = new HashSet<ObjectGeneration>();
            await EntireClassTree(processedObjs);
            return processedObjs;
        }

        private async Task EntireClassTree(HashSet<ObjectGeneration> processedObjs)
        {
            if (processedObjs.Contains(this)) return;
            processedObjs.Add(this);
            foreach (var subObj in await this.InheritingObjects())
            {
                await subObj.EntireClassTree(processedObjs);
            }
            if (this.HasLoquiBaseObject)
            {
                await this.BaseClass.EntireClassTree(processedObjs);
            }
        }

        public bool TestTrueAndNotBaseClass(Func<ObjectGeneration, bool> test)
        {
            return test(this) && !this.BaseClassTrail().Any(b => test(b));
        }

        public bool TestTrueForAnyInClassChain(Func<ObjectGeneration, bool> test)
        {
            return test(this) || this.BaseClassTrail().Any(b => test(b));
        }

        public override string ToString()
        {
            return $"{this.ProtoGen.Protocol.Namespace}.{this.Name}";
        }

        public void MarkFailure(Exception ex)
        {
            this._directlyInheritingObjectsTcs.TrySetException(ex);
            this.LoadingCompleteTask.TrySetException(ex);
            this.WiredBaseClassTCS.TrySetException(ex);
        }

        public string[] GenericTypeMaskWheres(LoquiInterfaceType type, params MaskType[] maskTypes)
        {
            return maskTypes.SelectMany(
                (maskType) =>
                {
                    switch (maskType)
                    {
                        case MaskType.Normal:
                            return GenerateWhereClauses(type)
                                .Select(where =>
                                {
                                    if (maskTypes.Contains(MaskType.NormalGetter))
                                    {
                                        where += ", TGetter";
                                        if (!where.Contains("ILoquiObjectSetter<T>"))
                                        {
                                            where += ", ILoquiObjectSetter<T>";
                                        }
                                    }
                                    return where;
                                });
                        case MaskType.NormalGetter:
                            return GenerateWhereClauses(
                                LoquiInterfaceType.IGetter,
                                this.Generics.Select(kv => new KeyValuePair<string, GenericDefinition>(MaskNickname(kv.Key, MaskType.NormalGetter), kv.Value)));
                        default:
                            break;
                    }
                    return Generics
                        .SelectWhere((g) =>
                        {
                            List<string> strs = new List<string>();
                            if (g.Value.BaseObjectGeneration != null)
                            {
                                strs.Add($"{g.Value.BaseObjectGeneration.Mask(maskType)}");
                            }
                            else if (g.Value.Loqui)
                            {
                                strs.Add("class");
                            }
                            else
                            {
                                return TryGet<string>.Failure;
                            }
                            if (maskType == MaskType.Error)
                            {
                                strs.Add($"IErrorMask<{MaskNickname(g.Key, maskType)}>");
                            }
                            if (maskType == MaskType.Translation)
                            {
                                strs.Add($"{nameof(ITranslationMask)}");
                            }
                            return TryGet<string>.Succeed($"where {g.Key}_{MaskModule.MaskNickname(maskType)} : {(string.Join(", ", strs))}");
                        });
                }).ToArray();
        }

        public IEnumerable<IEnumerable<string>> GetGenericTypeStrings(params MaskType[] maskTypes)
        {
            return maskTypes.Select(
                (maskType) =>
                {
                    switch (maskType)
                    {
                        case MaskType.Normal:
                            return Generics.Select((g) => g.Key);
                        case MaskType.NormalGetter:
                            return Generics.Select((g) => MaskNickname(g.Key, MaskType.NormalGetter));
                        case MaskType.Error:
                        case MaskType.Copy:
                        case MaskType.Translation:
                            return GenericTypes_Nickname(maskType);
                        default:
                            throw new NotImplementedException();
                    }
                });
        }

        public string GetGenericTypes(params MaskType[] maskTypes)
        {
            return GenerateGenericClause(GetGenericTypeStrings(maskTypes).ToArray());
        }

        public string GetGenericTypes(MaskType maskType, params string[] extraGenerics)
        {
            return GenerateGenericClause(GetGenericTypeStrings(maskType.AsEnumerable().ToArray()).And(extraGenerics).ToArray());
        }

        public string GetGenericTypesNickname(string nickName, params MaskType[] maskTypes)
        {
            return GenerateGenericClause(
                maskTypes.Select(
                    (maskType) =>
                    {
                        switch (maskType)
                        {
                            case MaskType.Normal:
                                return Generics.Select((g) => $"{g.Key}{nickName}");
                            case MaskType.NormalGetter:
                                return Generics.Select((g) => $"{MaskNickname(g.Key, MaskType.NormalGetter)}{nickName}");
                            case MaskType.Error:
                            case MaskType.Copy:
                            case MaskType.Translation:
                                return GenericTypes_Nickname(maskType).Select(s => $"{s}{nickName}");
                            default:
                                throw new NotImplementedException();
                        }
                    }).ToArray());
        }

        public string GetBaseGenericTypes(params MaskType[] maskTypes)
        {
            return GenerateGenericClause(
                maskTypes.Select(
                    (maskType) =>
                    {
                        switch (maskType)
                        {
                            case MaskType.Normal:
                                return BaseGenerics.Select((g) => g.Key);
                            case MaskType.Error:
                            case MaskType.Copy:
                            case MaskType.Translation:
                                return BaseGenericTypes_Nickname(maskType);
                            default:
                                throw new NotImplementedException();
                        }
                    }).ToArray());
        }

        public string GetTypeName(LoquiInterfaceType type)
        {
            switch (type)
            {
                case LoquiInterfaceType.Direct:
                    return this.Name;
                case LoquiInterfaceType.IGetter:
                    return this.Interface(getter: true, internalInterface: true);
                case LoquiInterfaceType.ISetter:
                    return this.Interface(getter: false, internalInterface: true);
                default:
                    throw new NotImplementedException();
            }
        }

        public bool IsObjectInterface(string str)
        {
            if (this.Interface(getter: true, internalInterface: true).Equals(str)) return true;
            if (this.Interface(getter: true, internalInterface: false).Equals(str)) return true;
            if (this.Interface(getter: false, internalInterface: true).Equals(str)) return true;
            if (this.Interface(getter: false, internalInterface: false).Equals(str)) return true;
            return false;
        }

        public string Interface(bool getter = false, bool internalInterface = false)
        {
            return Interface(
                genericTypes: this.GetGenericTypes(MaskType.Normal),
                getter: getter,
                internalInterface: internalInterface);
        }

        public string Interface(string genericTypes, bool getter = false, bool internalInterface = false)
        {
            var ret = InterfaceNoGenerics(
                getter: getter,
                internalInterface: internalInterface);
            return $"{ret}{genericTypes}";
        }

        public string Interface(MaskType[] maskTypes, bool getter = false, bool internalInterface = false)
        {
            if (maskTypes.Contains(MaskType.NormalGetter))
            {
                return Interface(
                    this.GetGenericTypes(MaskType.NormalGetter),
                    getter: getter,
                    internalInterface: internalInterface);
            }
            else
            {
                return Interface(
                    getter: getter,
                    internalInterface: internalInterface);
            }
        }

        public string InterfaceNoGenerics(bool getter = false, bool internalInterface = false)
        {
            return $"I{this.Name}{(internalInterface && ((getter && this.HasInternalGetInterface) || (!getter && this.HasInternalSetInterface)) ? "Internal" : null)}{(getter ? "Getter" : null)}";
        }

        public IAsyncEnumerable<string> GetApplicableInterfaces(LoquiInterfaceType type)
        {
            return this.gen.GenerationModules
                .ToAsyncEnumerable()
                .SelectMany((tr) => tr.Interfaces(this))
                .Where(i => i.Location == type)
                .Select(i => i.Interface);
        }

        private string GetEmptyGenerics(MaskType[] maskTypes)
        {
            if (maskTypes?.Length == 0)
            {
                return (this.Generics.Count > 0 ? $"<{string.Join(",", this.Generics.Select((g) => string.Empty))}>" : string.Empty);
            }

            string[] strs = maskTypes.Select(
                (maskType) =>
                {
                    switch (maskType)
                    {
                        case MaskType.Normal:
                            return Generics.Select((g) => g.Key);
                        case MaskType.Error:
                        case MaskType.Copy:
                        case MaskType.Translation:
                            return GenericTypes_Nickname(maskType);
                        default:
                            throw new NotImplementedException();
                    }
                })
                .SelectMany(s => s)
                .Select(s => string.Empty)
                .ToArray();
            return (strs.Length > 0 ? $"<{string.Join(",", strs)}>" : string.Empty);
        }
    }
}
